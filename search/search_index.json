{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contexto docente Este tutorial sirve como complemento docente para alumnos de grado y posgrado interesados en el estudio de la ciencia de datos , y se considera una continuaci\u00f3n del tutorial realizado por Ismael S\u00e1nchez Pareja , que fue creado como complemento para el aprendizaje de la materia \"Inform\u00e1tica Aplicada a la Bioqu\u00edmica\" , asignatura impartida en el grado de Bioqu\u00edmica en la Universidad de C\u00f3rdoba, en el cual se detallan los aspectos m\u00e1s b\u00e1sicos para la programaci\u00f3n en R. Por tanto, muchos conocimientos estudiados en \u00e9l se dan por aprendidos, tratando de expandirlos y de aplicarlos a ejemplos reales del \u00e1mbito de la Bioqu\u00edmica. Uso de R en el \u00e1mbito de la bioqu\u00edmica R es un entorno y lenguaje de programaci\u00f3n enfocado en el an\u00e1lisis estad\u00edstico, preparado para la observaci\u00f3n, manipulaci\u00f3n y representaci\u00f3n de datos, siendo capaz de adaptar una gran cantidad de t\u00e9cnicas estad\u00edsticas y gr\u00e1ficas. Adem\u00e1s, es altamente modificable empleando multitud de software y librer\u00edas de funciones. En definitiva, el lenguaje R es muy extenso , e intentar abarcarlo todo es una tarea muy compleja. Lo que se ha estudiado hasta ahora en R son los aspectos b\u00e1sicos de este lenguaje y c\u00f3mo manejarse con \u00e9l sin demasiada dificultad. Pero, \u00bfsabemos aplicar lo que conocemos en el desarrollo de nuestras propias tareas? Lo cierto es que esto es un poco m\u00e1s complicado. Es verdad que, por ahora, somos capaces de dise\u00f1ar estudios anal\u00edticos a nivel \"casero\", es decir, estudios simples con una cantidad de datos f\u00e1cilmente manejables (como pueden ser los obtenidos en una pr\u00e1ctica de laboratorio). Sin embargo, cuando nos encontramos en el \u00e1mbito laboral o el de investigaci\u00f3n, debemos trabajar con enormes cantidades de datos, imposibles de asimilar y examinar empleando \u00fanicamente nuestro cerebro. Es entonces cuando entra en juego la imprescindible ciencia de datos . El objetivo de este tutorial es, por tanto, ense\u00f1ar a estudiantes del grado de Bioqu\u00edmica y de posgrado a aplicar todos los conocimientos adquiridos en simulaciones de situaciones reales, con la finalidad de adquirir la capacidad de aplicarlos en sus propios estudios. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja","title":"Inicio"},{"location":"#contexto-docente","text":"Este tutorial sirve como complemento docente para alumnos de grado y posgrado interesados en el estudio de la ciencia de datos , y se considera una continuaci\u00f3n del tutorial realizado por Ismael S\u00e1nchez Pareja , que fue creado como complemento para el aprendizaje de la materia \"Inform\u00e1tica Aplicada a la Bioqu\u00edmica\" , asignatura impartida en el grado de Bioqu\u00edmica en la Universidad de C\u00f3rdoba, en el cual se detallan los aspectos m\u00e1s b\u00e1sicos para la programaci\u00f3n en R. Por tanto, muchos conocimientos estudiados en \u00e9l se dan por aprendidos, tratando de expandirlos y de aplicarlos a ejemplos reales del \u00e1mbito de la Bioqu\u00edmica.","title":"Contexto docente"},{"location":"#uso-de-r-en-el-ambito-de-la-bioquimica","text":"R es un entorno y lenguaje de programaci\u00f3n enfocado en el an\u00e1lisis estad\u00edstico, preparado para la observaci\u00f3n, manipulaci\u00f3n y representaci\u00f3n de datos, siendo capaz de adaptar una gran cantidad de t\u00e9cnicas estad\u00edsticas y gr\u00e1ficas. Adem\u00e1s, es altamente modificable empleando multitud de software y librer\u00edas de funciones. En definitiva, el lenguaje R es muy extenso , e intentar abarcarlo todo es una tarea muy compleja. Lo que se ha estudiado hasta ahora en R son los aspectos b\u00e1sicos de este lenguaje y c\u00f3mo manejarse con \u00e9l sin demasiada dificultad. Pero, \u00bfsabemos aplicar lo que conocemos en el desarrollo de nuestras propias tareas? Lo cierto es que esto es un poco m\u00e1s complicado. Es verdad que, por ahora, somos capaces de dise\u00f1ar estudios anal\u00edticos a nivel \"casero\", es decir, estudios simples con una cantidad de datos f\u00e1cilmente manejables (como pueden ser los obtenidos en una pr\u00e1ctica de laboratorio). Sin embargo, cuando nos encontramos en el \u00e1mbito laboral o el de investigaci\u00f3n, debemos trabajar con enormes cantidades de datos, imposibles de asimilar y examinar empleando \u00fanicamente nuestro cerebro. Es entonces cuando entra en juego la imprescindible ciencia de datos . El objetivo de este tutorial es, por tanto, ense\u00f1ar a estudiantes del grado de Bioqu\u00edmica y de posgrado a aplicar todos los conocimientos adquiridos en simulaciones de situaciones reales, con la finalidad de adquirir la capacidad de aplicarlos en sus propios estudios. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja","title":"Uso de R en el \u00e1mbito de la bioqu\u00edmica"},{"location":"acerca/","text":"Para concluir este tutorial, queremos, una vez m\u00e1s, hacer hincapi\u00e9 en la importancia de la inform\u00e1tica en cualquier rama de la ciencia actual. Actualmente en cualquier estudio cient\u00edfico es necesario el empleo de herramientas inform\u00e1ticas para el estudio de los resultados obtenidos ( ciencia de datos ). Por tanto, ahora m\u00e1s que nunca son necesarios cient\u00edficos con conocimientos en este campo. La finalidad de este tutorial ha sido despertar la curiosidad y el inter\u00e9s del alumnado de bioqu\u00edmica por el mundo bioinform\u00e1tico y ofrecer una v\u00eda de entrada lo m\u00e1s sencilla posible. Autores La versi\u00f3n inicial de este Tutorial de Programaci\u00f3n en R ha sido desarrollada como Trabajo Fin de Grado de la titulaci\u00f3n Grado en Bioqu\u00edmica , en la Universidad de C\u00f3rdoba , por el alumno Jos\u00e9 Carlos Redondo Navarro , y dirigida por el profesor Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez .","title":"Acerca de"},{"location":"acerca/#autores","text":"La versi\u00f3n inicial de este Tutorial de Programaci\u00f3n en R ha sido desarrollada como Trabajo Fin de Grado de la titulaci\u00f3n Grado en Bioqu\u00edmica , en la Universidad de C\u00f3rdoba , por el alumno Jos\u00e9 Carlos Redondo Navarro , y dirigida por el profesor Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez .","title":"Autores"},{"location":"ejercicios/","text":"Paquete learnr Para crear los ejercicios finales de algunos apartados hemos empleado el paquete \" learnr \". Este nos permite crear tutoriales interactivos en formato RMarkdown , un formato de edici\u00f3n de texto que nos permite incluir c\u00f3digo desde R (de hecho, este tutorial al completo est\u00e1 escrito en formato RMarkdown ). Estos tutoriales permiten el uso de multitud de objetos, como cuadros de c\u00f3digo en R, preguntas tipo test, im\u00e1genes y m\u00e1s, como herramienta de aprendizaje mientras programas. Si has ido resolviendo los ejercicios propuestos al final de cada apartado conforme avanzabas en el tutorial ya habr\u00e1s visto c\u00f3mo funciona y el potencial que tiene como herramienta interactiva. \u00bfC\u00f3mo hacer los ejercicios de repaso? En primer lugar, es necesario que instales y actives learnr : 1 2 install.packages ( \"learnr\" ) library ( learnr ) A continuaci\u00f3n, necesitas descargarte el paquete \" tutoradvr \" , que incluye los ejercicios de todos los apartados. Una vez descargado (no debes descomprimirlo), debes instalarlo en R de la siguiente manera: En RStudio, abre la pesta\u00f1a \" Tools \" y selecciona \" Install packages... \". Se abrir\u00e1 una ventana. En el cuadro \" Install from \", selecciona la opci\u00f3n \" Package Archive File (.zip; .tar.gz). \" Esto permite instalar los paquetes de forma local, sin recurrir a repositorios externos como CRAN. Luego, en el cuadro de \" Package archive \" busca donde hayas descargado el paquete (en nuestro caso, la carpeta de descargas) y selecci\u00f3nalo. Aparecer\u00e1n una serie de l\u00edneas de comando en la consola, tras lo cual el paquete quedar\u00e1 instalado. Puedes comprobarlo en la pesta\u00f1a \" Packages \": Finalmente, activa el paquete usando el comando library() : 1 library ( tutoradvr ) Comandos por apartado Para realizar los ejercicios, simplemente ejecuta los siguientes comandos en la consola: 1 2 3 # Apartado \"Visualizar datos\" learnr :: run_tutorial ( \"visualizar\" , \"tutoradvr\" ) 1 2 3 # Apartado \"Importar datos\" learnr :: run_tutorial ( \"importar\" , \"tutoradvr\" ) 1 2 3 # Apartado \"Ordenar datos\" learnr :: run_tutorial ( \"ordenar\" , \"tutoradvr\" ) 1 2 3 # Apartado \"Modelar datos\" learnr :: run_tutorial ( \"modelar\" , \"tutoradvr\" ) Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Interactive Tutorials for R ; Garrett Grolemund Generando tutoriales interactivos con el paquete learnr ; Yanina Bellini Saibene How to deliver learnr tutorials in a package ; Desir\u00e9e De Leon RStudio para Estad\u00edstica Descriptiva en Ciencias Sociales ; Boccardo Bosoni et al.","title":"Realizaci\u00f3n de ejercicios"},{"location":"ejercicios/#paquete-learnr","text":"Para crear los ejercicios finales de algunos apartados hemos empleado el paquete \" learnr \". Este nos permite crear tutoriales interactivos en formato RMarkdown , un formato de edici\u00f3n de texto que nos permite incluir c\u00f3digo desde R (de hecho, este tutorial al completo est\u00e1 escrito en formato RMarkdown ). Estos tutoriales permiten el uso de multitud de objetos, como cuadros de c\u00f3digo en R, preguntas tipo test, im\u00e1genes y m\u00e1s, como herramienta de aprendizaje mientras programas. Si has ido resolviendo los ejercicios propuestos al final de cada apartado conforme avanzabas en el tutorial ya habr\u00e1s visto c\u00f3mo funciona y el potencial que tiene como herramienta interactiva.","title":"Paquete learnr"},{"location":"ejercicios/#como-hacer-los-ejercicios-de-repaso","text":"En primer lugar, es necesario que instales y actives learnr : 1 2 install.packages ( \"learnr\" ) library ( learnr ) A continuaci\u00f3n, necesitas descargarte el paquete \" tutoradvr \" , que incluye los ejercicios de todos los apartados. Una vez descargado (no debes descomprimirlo), debes instalarlo en R de la siguiente manera: En RStudio, abre la pesta\u00f1a \" Tools \" y selecciona \" Install packages... \". Se abrir\u00e1 una ventana. En el cuadro \" Install from \", selecciona la opci\u00f3n \" Package Archive File (.zip; .tar.gz). \" Esto permite instalar los paquetes de forma local, sin recurrir a repositorios externos como CRAN. Luego, en el cuadro de \" Package archive \" busca donde hayas descargado el paquete (en nuestro caso, la carpeta de descargas) y selecci\u00f3nalo. Aparecer\u00e1n una serie de l\u00edneas de comando en la consola, tras lo cual el paquete quedar\u00e1 instalado. Puedes comprobarlo en la pesta\u00f1a \" Packages \": Finalmente, activa el paquete usando el comando library() : 1 library ( tutoradvr )","title":"\u00bfC\u00f3mo hacer los ejercicios de repaso?"},{"location":"ejercicios/#comandos-por-apartado","text":"Para realizar los ejercicios, simplemente ejecuta los siguientes comandos en la consola: 1 2 3 # Apartado \"Visualizar datos\" learnr :: run_tutorial ( \"visualizar\" , \"tutoradvr\" ) 1 2 3 # Apartado \"Importar datos\" learnr :: run_tutorial ( \"importar\" , \"tutoradvr\" ) 1 2 3 # Apartado \"Ordenar datos\" learnr :: run_tutorial ( \"ordenar\" , \"tutoradvr\" ) 1 2 3 # Apartado \"Modelar datos\" learnr :: run_tutorial ( \"modelar\" , \"tutoradvr\" ) Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Interactive Tutorials for R ; Garrett Grolemund Generando tutoriales interactivos con el paquete learnr ; Yanina Bellini Saibene How to deliver learnr tutorials in a package ; Desir\u00e9e De Leon RStudio para Estad\u00edstica Descriptiva en Ciencias Sociales ; Boccardo Bosoni et al.","title":"Comandos por apartado"},{"location":"genesis/","text":"Bioconductor Bioconductor es un repositorio de paquetes para R, dise\u00f1ados para el an\u00e1lisis y comprensi\u00f3n de grandes cantidades de datos gen\u00f3micos. Estos paquetes pueden clasificarse en cuatro tipos: Software , paquetes de funciones para usar en nuestros an\u00e1lisis de datos. Anotaci\u00f3n , para la interacci\u00f3n con bases de datos gen\u00f3micos. Datos experimentales , distribuci\u00f3n de datos de experimentos, como los que hemos usado en apartados anteriores. Workflow , muestran c\u00f3mo usar paquetes de R y/o Bioconductor en un an\u00e1lisis concreto. La cantidad de paquetes que ofrece este repositorio es enorme, y es imposible conocerlos todos. Cada investigador emplear\u00e1 unos paquetes u otros, dependiendo de las necesidades de su trabajo. La selecci\u00f3n de paquetes que ofrece cada uno es, por tanto, muy personal. Si necesitas tener una visi\u00f3n global sobre lo que ofrece Bioconductor es recomendable empezar a buscar por su p\u00e1gina de ayuda . Instalaci\u00f3n de paquetes Para instalar paquetes de Bioconductor, primero debemos instalar BiocManager , paquete que administra la instalaci\u00f3n de aquellos que se encuentran en Bioconductor . Esto es muy sencillo, simplemente copia y pega lo siguiente en la consola de R: 1 2 3 if ( ! requireNamespace ( \"BiocManager\" , quietly = TRUE )) install.packages ( \"BiocManager\" ) BiocManager :: install ( version = \"3.12\" ) Una vez ha terminado (puede tardar unos minutos), el paquete instala la versi\u00f3n m\u00e1s reciente (en el momento de creaci\u00f3n de este tutorial, la 3.12; puede haberse lanzado una nueva versi\u00f3n, aunque el m\u00e9todo de instalaci\u00f3n es el mismo) y ya puedes instalar cualquier paquete de Bioconductor . Para ello, entra en la p\u00e1gina del paquete en el que est\u00e9s interesado. Abajo te aparecer\u00e1 un cuadro de c\u00f3digo para que lo copies y lo pegues en la consola: En este ejemplo, el texto ser\u00e1 el siguiente. C\u00f3pialo y p\u00e9galo en la consola para instalar GENESIS , pues lo vamos a usar como ejemplo a continuaci\u00f3n. 1 2 3 4 if ( ! requireNamespace ( \"BiocManager\" , quietly = TRUE )) install.packages ( \"BiocManager\" ) BiocManager :: install ( \"GENESIS\" ) 1 library ( GENESIS ) Nota Como ver\u00e1s, antes de instalar el paquete, el comando comprueba si tienes instalado BiocManager . Si no es as\u00ed, lo instalar\u00e1 de forma silenciosa. C\u00f3mo usar paquetes de Bioconductor Cada paquete incluye su propia \" vignette \" (una gu\u00eda con toda la informaci\u00f3n necesaria que aparece en la ventana \" Help \"), que puedes ver usando: 1 ?< NOMBRE_PAQUETE > Tambi\u00e9n puedes ver toda la informaci\u00f3n en el navegador o en formato .pdf justo debajo de la secci\u00f3n de instalaci\u00f3n en la p\u00e1gina del paquete. Paquete GENESIS Uno de estos paquetes es GENESIS ( GENetic EStimation and Inference in Structured samples ). Este contiene una serie de herramientas para trabajar con numerosas metodolog\u00edas complejas dentro del campo del an\u00e1lisis de secuencias gen\u00f3micas. GENESIS presenta dos programas \u00fanicos para el an\u00e1lisis de datos gen\u00f3micos de muestras con estructura poblacional y/o parentesco: PC-AiR y PC-Relate . PC-AiR PC-AiR ( Principal Components Analysis in Related Samples ) es un m\u00e9todo basado en PCA ( Principal Components Analysis ), que se aplica en el genotipado de cientos de miles de polimorfismos puntuales (SNPs; Single Nucleotide Polymorphisms) a lo largo de todo el genoma de las muestras para agruparlos en Componentes Principales ( PCs ) y estudiar la inferencia de estructura poblacional. Sin embargo, PCA no tiene en cuenta el posible parentesco que exista entre las muestras analizadas, cuesti\u00f3n clave a la hora de identificar SNPs. PC-AiR , por el contrario, s\u00ed que tiene en cuenta el parentesco, pudiendo as\u00ed identificar SNPs y PCs con mayor precisi\u00f3n. PC-Relate PC-Relate ( Relatedness Estimation Adjusted for Principal Components ) es capaz de estimar el parentesco entre muestras sin estructura poblacional especificada, empleando PCs de poblaciones representativas muy estudiadas e indexadas, calculadas con PC-AiR . An\u00e1lisis de secuencias gen\u00f3micas Tanto PC-AiR como PC-Relate son las herramientas principales que usa GENESIS para el resto de aplicaciones, pudiendo emplearse en multitud de tareas de genotipado de muestras. Por ejemplo, a la hora del an\u00e1lisis de secuencias, los PCs de PC-AiR pueden usarse para la estratificaci\u00f3n de una poblaci\u00f3n, y PC-Relate se emplea para determinar la correlaci\u00f3n fenot\u00edpica en la muestra. Ejemplos Un ejemplo de c\u00f3mo puede usarse este paquete es el siguiente. Imaginemos que necesitamos saber que PCs son ancestrales dentro de una determinada poblaci\u00f3n. Para ello, en un eje de coordenadas se enfrentan los genomas de 1000 individuos de poblaciones distintas. Nota Este apartado es opcional, as\u00ed que simplemente puedes seguir leyendo y no es necesario que lo realices por ti mismo. Primero, instalamos y ejecutamos los siguientes paquetes (si no los tienes instalados ya): 1 2 3 install.packages ( \"dplyr\" ) install.packages ( \"RColorBrewer\" ) install.packages ( \"GGally\" ) 1 2 3 4 library ( dplyr ) library ( RColorBrewer ) library ( ggplot2 ) library ( GGally ) A continuaci\u00f3n representamos los SNPs, que est\u00e1n incluidos en un archivo .gds que contiene toda la informaci\u00f3n de variaciones de la secuencia problema (en este ejemplo, SeqData ). Primero debemos definir una variable que contenga la informaci\u00f3n necesaria. Para ello, se usa el comando pcair() : 1 2 3 4 pcs <- pcair ( seqData , # Con \"pcair\" realizamos el an\u00e1lisis de SNPs sobre SeqData kinobj = kingMat , kin.thresh = 2 ^ ( -9 / 2 ), # \"kinobj\" calcula el parentesco entre las muestras divobj = kingMat , div.thresh = -2 ^ ( -9 / 2 ), # \"divobj\" calcula la divergencia ancestral snp.include = pruned ) # Incluye m\u00e1s SNPs para el estudio Despu\u00e9s, trabajamos exclusivamente con el apartado de vectores de la variable creada, que contiene los PCs: 1 2 3 4 5 6 7 8 pc.df <- as.data.frame ( pcs $ vectors ) # En este bloque definimos los names ( pc.df ) <- paste0 ( \"PC\" , 1 : ncol ( pcs $ vectors )) # nombres de las diferentes pc.df $ sample.id <- row.names ( pcs $ vectors ) # variables (poblaciones) y sus pc.df <- left_join ( pc.df , pData ( annot ), by = \"sample.id\" ) # casos particulares. pop.cols <- setNames ( brewer.pal ( 12 , \"Paired\" ), # Aqu\u00ed especificamos el nombre de c ( \"ACB\" , \"ASW\" , \"CEU\" , \"GBR\" , \"CHB\" , \"JPT\" , # las poblaciones. \"CLM\" , \"MXL\" , \"LWK\" , \"YRI\" , \"GIH\" , \"PUR\" )) Finalmente, representamos los datos en un diagrama de dispersi\u00f3n de la siguiente forma: 1 2 ggplot ( pc.df , aes ( PC1 , PC2 , color = Population )) + geom_point () + # Aqu\u00ed PC1 y PC2 son dos de los scale_color_manual ( values = pop.cols ) # muchos PC que emplea PC-AiR Puedes tambi\u00e9n representar estos mismos datos, pero teniendo en cuenta el grado de relaci\u00f3n que existe entre las diferentes poblaciones y los PCs con un diagrama de l\u00edneas: 1 2 3 ggparcoord ( pc.df , columns = 1 : 10 , groupColumn = \"Population\" , scale = \"uniminmax\" ) + scale_color_manual ( values = pop.cols ) + xlab ( \"PC\" ) + ylab ( \"\" ) Viendo esta \u00faltima gr\u00e1fica podemos ver c\u00f3mo la relaci\u00f3n entre las poblaciones y los PCs es muy variable. Por ejemplo, JPT y CHB (l\u00edneas roja y rosa respectivamente) presentan una alta relaci\u00f3n con el set de PC n\u00famero dos, mientras que apenas la tiene con el n\u00famero 1. Apreciamos tambi\u00e9n cierto grado de relaci\u00f3n de estas dos poblaciones con el resto de PCs. Como puedes deducir con estos estudios, trabajar con este tipo de programas requiere de tiempo y dedicaci\u00f3n. Puedes estudiarlos m\u00e1s detalladamente en la p\u00e1gina de documentaci\u00f3n de GENESIS, de donde provienen estos ejemplos. Resumen Las posibilidades que ofrece este paquete (y todos los dem\u00e1s) son casi ilimitadas y, como se ha mencionado anteriormente, es casi imposible conocerlas todas, pues necesitas trabajar durante mucho tiempo con un determinado conjunto de paquetes para poder manejarlo con soltura. La introducci\u00f3n a este mundo puede ser bastante complicada en un principio, pero no tarda mucho en compensar el esfuerzo. En este tutorial hemos mostrado el potencial que ofrece GENESIS a la hora de trabajar como bioqu\u00edmicos, pero existen muchos m\u00e1s y, de nuevo, los paquetes que uses van a depender de tus necesidades laborales. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Bioconductor ; Help R & Bioconductor Manual ; T. Girke, UC Riverside GENESIS ; Bioconductor","title":"Bioconductor y GENESIS"},{"location":"genesis/#bioconductor","text":"Bioconductor es un repositorio de paquetes para R, dise\u00f1ados para el an\u00e1lisis y comprensi\u00f3n de grandes cantidades de datos gen\u00f3micos. Estos paquetes pueden clasificarse en cuatro tipos: Software , paquetes de funciones para usar en nuestros an\u00e1lisis de datos. Anotaci\u00f3n , para la interacci\u00f3n con bases de datos gen\u00f3micos. Datos experimentales , distribuci\u00f3n de datos de experimentos, como los que hemos usado en apartados anteriores. Workflow , muestran c\u00f3mo usar paquetes de R y/o Bioconductor en un an\u00e1lisis concreto. La cantidad de paquetes que ofrece este repositorio es enorme, y es imposible conocerlos todos. Cada investigador emplear\u00e1 unos paquetes u otros, dependiendo de las necesidades de su trabajo. La selecci\u00f3n de paquetes que ofrece cada uno es, por tanto, muy personal. Si necesitas tener una visi\u00f3n global sobre lo que ofrece Bioconductor es recomendable empezar a buscar por su p\u00e1gina de ayuda .","title":"Bioconductor"},{"location":"genesis/#instalacion-de-paquetes","text":"Para instalar paquetes de Bioconductor, primero debemos instalar BiocManager , paquete que administra la instalaci\u00f3n de aquellos que se encuentran en Bioconductor . Esto es muy sencillo, simplemente copia y pega lo siguiente en la consola de R: 1 2 3 if ( ! requireNamespace ( \"BiocManager\" , quietly = TRUE )) install.packages ( \"BiocManager\" ) BiocManager :: install ( version = \"3.12\" ) Una vez ha terminado (puede tardar unos minutos), el paquete instala la versi\u00f3n m\u00e1s reciente (en el momento de creaci\u00f3n de este tutorial, la 3.12; puede haberse lanzado una nueva versi\u00f3n, aunque el m\u00e9todo de instalaci\u00f3n es el mismo) y ya puedes instalar cualquier paquete de Bioconductor . Para ello, entra en la p\u00e1gina del paquete en el que est\u00e9s interesado. Abajo te aparecer\u00e1 un cuadro de c\u00f3digo para que lo copies y lo pegues en la consola: En este ejemplo, el texto ser\u00e1 el siguiente. C\u00f3pialo y p\u00e9galo en la consola para instalar GENESIS , pues lo vamos a usar como ejemplo a continuaci\u00f3n. 1 2 3 4 if ( ! requireNamespace ( \"BiocManager\" , quietly = TRUE )) install.packages ( \"BiocManager\" ) BiocManager :: install ( \"GENESIS\" ) 1 library ( GENESIS ) Nota Como ver\u00e1s, antes de instalar el paquete, el comando comprueba si tienes instalado BiocManager . Si no es as\u00ed, lo instalar\u00e1 de forma silenciosa.","title":"Instalaci\u00f3n de paquetes"},{"location":"genesis/#como-usar-paquetes-de-bioconductor","text":"Cada paquete incluye su propia \" vignette \" (una gu\u00eda con toda la informaci\u00f3n necesaria que aparece en la ventana \" Help \"), que puedes ver usando: 1 ?< NOMBRE_PAQUETE > Tambi\u00e9n puedes ver toda la informaci\u00f3n en el navegador o en formato .pdf justo debajo de la secci\u00f3n de instalaci\u00f3n en la p\u00e1gina del paquete.","title":"C\u00f3mo usar paquetes de Bioconductor"},{"location":"genesis/#paquete-genesis","text":"Uno de estos paquetes es GENESIS ( GENetic EStimation and Inference in Structured samples ). Este contiene una serie de herramientas para trabajar con numerosas metodolog\u00edas complejas dentro del campo del an\u00e1lisis de secuencias gen\u00f3micas. GENESIS presenta dos programas \u00fanicos para el an\u00e1lisis de datos gen\u00f3micos de muestras con estructura poblacional y/o parentesco: PC-AiR y PC-Relate .","title":"Paquete GENESIS"},{"location":"genesis/#pc-air","text":"PC-AiR ( Principal Components Analysis in Related Samples ) es un m\u00e9todo basado en PCA ( Principal Components Analysis ), que se aplica en el genotipado de cientos de miles de polimorfismos puntuales (SNPs; Single Nucleotide Polymorphisms) a lo largo de todo el genoma de las muestras para agruparlos en Componentes Principales ( PCs ) y estudiar la inferencia de estructura poblacional. Sin embargo, PCA no tiene en cuenta el posible parentesco que exista entre las muestras analizadas, cuesti\u00f3n clave a la hora de identificar SNPs. PC-AiR , por el contrario, s\u00ed que tiene en cuenta el parentesco, pudiendo as\u00ed identificar SNPs y PCs con mayor precisi\u00f3n.","title":"PC-AiR"},{"location":"genesis/#pc-relate","text":"PC-Relate ( Relatedness Estimation Adjusted for Principal Components ) es capaz de estimar el parentesco entre muestras sin estructura poblacional especificada, empleando PCs de poblaciones representativas muy estudiadas e indexadas, calculadas con PC-AiR .","title":"PC-Relate"},{"location":"genesis/#analisis-de-secuencias-genomicas","text":"Tanto PC-AiR como PC-Relate son las herramientas principales que usa GENESIS para el resto de aplicaciones, pudiendo emplearse en multitud de tareas de genotipado de muestras. Por ejemplo, a la hora del an\u00e1lisis de secuencias, los PCs de PC-AiR pueden usarse para la estratificaci\u00f3n de una poblaci\u00f3n, y PC-Relate se emplea para determinar la correlaci\u00f3n fenot\u00edpica en la muestra.","title":"An\u00e1lisis de secuencias gen\u00f3micas"},{"location":"genesis/#ejemplos","text":"Un ejemplo de c\u00f3mo puede usarse este paquete es el siguiente. Imaginemos que necesitamos saber que PCs son ancestrales dentro de una determinada poblaci\u00f3n. Para ello, en un eje de coordenadas se enfrentan los genomas de 1000 individuos de poblaciones distintas. Nota Este apartado es opcional, as\u00ed que simplemente puedes seguir leyendo y no es necesario que lo realices por ti mismo. Primero, instalamos y ejecutamos los siguientes paquetes (si no los tienes instalados ya): 1 2 3 install.packages ( \"dplyr\" ) install.packages ( \"RColorBrewer\" ) install.packages ( \"GGally\" ) 1 2 3 4 library ( dplyr ) library ( RColorBrewer ) library ( ggplot2 ) library ( GGally ) A continuaci\u00f3n representamos los SNPs, que est\u00e1n incluidos en un archivo .gds que contiene toda la informaci\u00f3n de variaciones de la secuencia problema (en este ejemplo, SeqData ). Primero debemos definir una variable que contenga la informaci\u00f3n necesaria. Para ello, se usa el comando pcair() : 1 2 3 4 pcs <- pcair ( seqData , # Con \"pcair\" realizamos el an\u00e1lisis de SNPs sobre SeqData kinobj = kingMat , kin.thresh = 2 ^ ( -9 / 2 ), # \"kinobj\" calcula el parentesco entre las muestras divobj = kingMat , div.thresh = -2 ^ ( -9 / 2 ), # \"divobj\" calcula la divergencia ancestral snp.include = pruned ) # Incluye m\u00e1s SNPs para el estudio Despu\u00e9s, trabajamos exclusivamente con el apartado de vectores de la variable creada, que contiene los PCs: 1 2 3 4 5 6 7 8 pc.df <- as.data.frame ( pcs $ vectors ) # En este bloque definimos los names ( pc.df ) <- paste0 ( \"PC\" , 1 : ncol ( pcs $ vectors )) # nombres de las diferentes pc.df $ sample.id <- row.names ( pcs $ vectors ) # variables (poblaciones) y sus pc.df <- left_join ( pc.df , pData ( annot ), by = \"sample.id\" ) # casos particulares. pop.cols <- setNames ( brewer.pal ( 12 , \"Paired\" ), # Aqu\u00ed especificamos el nombre de c ( \"ACB\" , \"ASW\" , \"CEU\" , \"GBR\" , \"CHB\" , \"JPT\" , # las poblaciones. \"CLM\" , \"MXL\" , \"LWK\" , \"YRI\" , \"GIH\" , \"PUR\" )) Finalmente, representamos los datos en un diagrama de dispersi\u00f3n de la siguiente forma: 1 2 ggplot ( pc.df , aes ( PC1 , PC2 , color = Population )) + geom_point () + # Aqu\u00ed PC1 y PC2 son dos de los scale_color_manual ( values = pop.cols ) # muchos PC que emplea PC-AiR Puedes tambi\u00e9n representar estos mismos datos, pero teniendo en cuenta el grado de relaci\u00f3n que existe entre las diferentes poblaciones y los PCs con un diagrama de l\u00edneas: 1 2 3 ggparcoord ( pc.df , columns = 1 : 10 , groupColumn = \"Population\" , scale = \"uniminmax\" ) + scale_color_manual ( values = pop.cols ) + xlab ( \"PC\" ) + ylab ( \"\" ) Viendo esta \u00faltima gr\u00e1fica podemos ver c\u00f3mo la relaci\u00f3n entre las poblaciones y los PCs es muy variable. Por ejemplo, JPT y CHB (l\u00edneas roja y rosa respectivamente) presentan una alta relaci\u00f3n con el set de PC n\u00famero dos, mientras que apenas la tiene con el n\u00famero 1. Apreciamos tambi\u00e9n cierto grado de relaci\u00f3n de estas dos poblaciones con el resto de PCs. Como puedes deducir con estos estudios, trabajar con este tipo de programas requiere de tiempo y dedicaci\u00f3n. Puedes estudiarlos m\u00e1s detalladamente en la p\u00e1gina de documentaci\u00f3n de GENESIS, de donde provienen estos ejemplos.","title":"Ejemplos"},{"location":"genesis/#resumen","text":"Las posibilidades que ofrece este paquete (y todos los dem\u00e1s) son casi ilimitadas y, como se ha mencionado anteriormente, es casi imposible conocerlas todas, pues necesitas trabajar durante mucho tiempo con un determinado conjunto de paquetes para poder manejarlo con soltura. La introducci\u00f3n a este mundo puede ser bastante complicada en un principio, pero no tarda mucho en compensar el esfuerzo. En este tutorial hemos mostrado el potencial que ofrece GENESIS a la hora de trabajar como bioqu\u00edmicos, pero existen muchos m\u00e1s y, de nuevo, los paquetes que uses van a depender de tus necesidades laborales. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Bioconductor ; Help R & Bioconductor Manual ; T. Girke, UC Riverside GENESIS ; Bioconductor","title":"Resumen"},{"location":"importar/","text":"Introducci\u00f3n Tras concluir el apartado anterior, sabemos mucho sobre representaci\u00f3n gr\u00e1fica. Sin embargo, todav\u00eda no conocemos c\u00f3mo emplear todo lo estudiado en nuestros propios trabajos. A partir de este momento, vamos a seguir el flujo normal de trabajo en la ciencia de datos , de forma que vamos a ser capaces de importar, ordenar y modificar nuestros propios sets de datos. Vamos a emplear el paquete de Tidyverse readr , que es el que se encarga de importar los datos . Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse ) Tibbles Antes de continuar con el apartado de importaci\u00f3n de datos, es importante conocer lo que son los tibbles . El c\u00f3digo base de R utiliza data frames a la hora de representar datos en tablas. Sin embargo, estos son un poco antiguos y a veces se hace un poco engorroso trabajar con ellos. Tidyverse trata de solucionar esto empleando el paquete \" tibble \". Los tibbles funcionan muy parecido a los data frame , pero presentan caracter\u00edsticas que los hace mucho m\u00e1s sencillo trabajar con ellos: Son mucho m\u00e1s r\u00e1pidos . No transforman los vectores de caracteres a factores , cosa que s\u00ed ocurre con los data.frame . Son m\u00e1s reproducibles , es decir, es m\u00e1s probable que aquellos que trabajen con los mismos datos que t\u00fa lleguen a los mismos resultados. Podemos transformar cualquier data frame en un tibble empleando as_tibble() . Por ejemplo, usemos esta funci\u00f3n con iris , un data frame incluido en R: 1 as_tibble ( iris ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 150 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species <dbl> <dbl> <dbl> <dbl> <fct> 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 7 4.6 3.4 1.4 0.3 setosa 8 5 3.4 1.5 0.2 setosa 9 4.4 2.9 1.4 0.2 setosa 10 4.9 3.1 1.5 0.1 setosa # ... with 140 more rows Tambi\u00e9n puedes crear tus propios tibbles desde cero. Para ello, empleamos la funci\u00f3n tibble() , que construye las tablas por columnas. Por ejemplo: 1 2 3 4 5 tibble ( \"Columna 1\" = 1 : 5 , \"Columna 2\" = 2 , \"Columna 3\" = c ( 2 , 7 , 4 , 1 , 4 ), ) 1 2 3 4 5 6 7 8 # A tibble: 5 x 3 `Columna 1` `Columna 2` `Columna 3` <int> <dbl> <dbl> 1 1 2 2 2 2 2 7 3 3 2 4 4 4 2 1 5 5 2 4 Nota Los tibbles ofrecen muchas posibilidades a la hora de crear tablas de datos. Si quieres saber m\u00e1s, puedes usar el comando ?tibble , o puedes consultar el manual oficial de Tidyverse aqu\u00ed . Importando datos Importar archivos de datos es muy sencillo, simplemente usa una de las siguientes funciones, dependiendo del tipo de delimitador por el que est\u00e9n separados tus datos: FUNCI\u00d3N DELIMITADOR read_csv() Coma read_csv2() Punto y coma read_tsv() Tabulaciones read_table() Espacio Razona: Encuentra un comando con el que puedas leer archivos con cualquier delimitador. Pista: Puedes revistar todos los comandos disponibles con ?read_delim Respuesta 1 read_delim ( \"<DATOS>\" , < DELIMITADOR > ) Si, por ejemplo, nuestro archivo llamado datos.txt emplea barras (/) como delimitadores escribimos: 1 read_delim ( \"datos.txt\" , / ) A partir de ahora, salvo excepciones, vamos a utilizar datos no incluidos dentro del paquete Tidyverse , empleando alguna de las funciones anteriores u otros paquetes. Ejercicio Adelantemos un poco de trabajo. Abre y descarga este conjunto de datos y, teniendo en cuenta sus delimitadores, imp\u00f3rtalo a R. Respuesta Antes de bajarlo podemos comprobar que el archivo emplea tabulaciones como delimitadores. Por tanto, tras descargarlo en nuestro working directory , lo importamos y le asignamos la variable datos : 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver como nuestros datos ahora aparecen en la ventana environment , listos para ser usados: Ejercicios Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"importar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja R for Data Science ; Hadley Wickham, Garrett Grolemund et al. Morphometric discrimination of two allozymically diagnosed sibling species ; Wayland, Matthew T. et al.","title":"Importar datos"},{"location":"importar/#introduccion","text":"Tras concluir el apartado anterior, sabemos mucho sobre representaci\u00f3n gr\u00e1fica. Sin embargo, todav\u00eda no conocemos c\u00f3mo emplear todo lo estudiado en nuestros propios trabajos. A partir de este momento, vamos a seguir el flujo normal de trabajo en la ciencia de datos , de forma que vamos a ser capaces de importar, ordenar y modificar nuestros propios sets de datos. Vamos a emplear el paquete de Tidyverse readr , que es el que se encarga de importar los datos . Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse )","title":"Introducci\u00f3n"},{"location":"importar/#tibbles","text":"Antes de continuar con el apartado de importaci\u00f3n de datos, es importante conocer lo que son los tibbles . El c\u00f3digo base de R utiliza data frames a la hora de representar datos en tablas. Sin embargo, estos son un poco antiguos y a veces se hace un poco engorroso trabajar con ellos. Tidyverse trata de solucionar esto empleando el paquete \" tibble \". Los tibbles funcionan muy parecido a los data frame , pero presentan caracter\u00edsticas que los hace mucho m\u00e1s sencillo trabajar con ellos: Son mucho m\u00e1s r\u00e1pidos . No transforman los vectores de caracteres a factores , cosa que s\u00ed ocurre con los data.frame . Son m\u00e1s reproducibles , es decir, es m\u00e1s probable que aquellos que trabajen con los mismos datos que t\u00fa lleguen a los mismos resultados. Podemos transformar cualquier data frame en un tibble empleando as_tibble() . Por ejemplo, usemos esta funci\u00f3n con iris , un data frame incluido en R: 1 as_tibble ( iris ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 150 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species <dbl> <dbl> <dbl> <dbl> <fct> 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 7 4.6 3.4 1.4 0.3 setosa 8 5 3.4 1.5 0.2 setosa 9 4.4 2.9 1.4 0.2 setosa 10 4.9 3.1 1.5 0.1 setosa # ... with 140 more rows Tambi\u00e9n puedes crear tus propios tibbles desde cero. Para ello, empleamos la funci\u00f3n tibble() , que construye las tablas por columnas. Por ejemplo: 1 2 3 4 5 tibble ( \"Columna 1\" = 1 : 5 , \"Columna 2\" = 2 , \"Columna 3\" = c ( 2 , 7 , 4 , 1 , 4 ), ) 1 2 3 4 5 6 7 8 # A tibble: 5 x 3 `Columna 1` `Columna 2` `Columna 3` <int> <dbl> <dbl> 1 1 2 2 2 2 2 7 3 3 2 4 4 4 2 1 5 5 2 4 Nota Los tibbles ofrecen muchas posibilidades a la hora de crear tablas de datos. Si quieres saber m\u00e1s, puedes usar el comando ?tibble , o puedes consultar el manual oficial de Tidyverse aqu\u00ed .","title":"Tibbles"},{"location":"importar/#importando-datos","text":"Importar archivos de datos es muy sencillo, simplemente usa una de las siguientes funciones, dependiendo del tipo de delimitador por el que est\u00e9n separados tus datos: FUNCI\u00d3N DELIMITADOR read_csv() Coma read_csv2() Punto y coma read_tsv() Tabulaciones read_table() Espacio Razona: Encuentra un comando con el que puedas leer archivos con cualquier delimitador. Pista: Puedes revistar todos los comandos disponibles con ?read_delim Respuesta 1 read_delim ( \"<DATOS>\" , < DELIMITADOR > ) Si, por ejemplo, nuestro archivo llamado datos.txt emplea barras (/) como delimitadores escribimos: 1 read_delim ( \"datos.txt\" , / ) A partir de ahora, salvo excepciones, vamos a utilizar datos no incluidos dentro del paquete Tidyverse , empleando alguna de las funciones anteriores u otros paquetes. Ejercicio Adelantemos un poco de trabajo. Abre y descarga este conjunto de datos y, teniendo en cuenta sus delimitadores, imp\u00f3rtalo a R. Respuesta Antes de bajarlo podemos comprobar que el archivo emplea tabulaciones como delimitadores. Por tanto, tras descargarlo en nuestro working directory , lo importamos y le asignamos la variable datos : 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver como nuestros datos ahora aparecen en la ventana environment , listos para ser usados:","title":"Importando datos"},{"location":"importar/#ejercicios","text":"Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"importar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja R for Data Science ; Hadley Wickham, Garrett Grolemund et al. Morphometric discrimination of two allozymically diagnosed sibling species ; Wayland, Matthew T. et al.","title":"Ejercicios"},{"location":"modelar/","text":"Introducci\u00f3n Modelar consiste en la aplicaci\u00f3n de herramientas matem\u00e1ticas para caracterizar un conjunto de datos y encontrar relaciones entre ellos, con las que somos capaces de: Predecir futuros resultados Encontrar patrones y diferencias entre variables Mejorar la visualizaci\u00f3n de los resultados A la hora de modelar, existen dos partes a seguir: Primero, debemos encontrar un patr\u00f3n dentro de los datos, que puede ser desde una relaci\u00f3n lineal simple \\(y = a\u00b7x + b\\) hasta una curva cuadr\u00e1tica \\(y = a\u00b7x^b\\) , siendo \\(x\\) e \\(y\\) las variables conocidas y \\(a\\) y \\(b\\) los par\u00e1metros que podemos modificar para encontrar la relaci\u00f3n. Tras esto, conociendo el patr\u00f3n, debemos encontrar el modelo que se ajusta a los datos (es decir, definir \\(a\\) y \\(b\\) ) Nota Hay que tener en cuenta que ning\u00fan modelo elegido es perfecto , simplemente es el que mejor se ajusta a los datos. Hay veces en el que el mejor modelo simplemente es malo y no tiene el por qu\u00e9 cumplirse en todos los casos. En esta parte del tutorial, adem\u00e1s de tidyverse , emplearemos el paquete modelr , incluido en R base y que nos dar\u00e1 algunas herramientas para comenzar a modelar. Adem\u00e1s, vamos a usar modeldata , que incluye una serie de conjuntos de datos preparados para aprender a modelar. Instalamos los paquetes y los cargamos: 1 install.packages ( \"modeldata\" ) 1 2 3 library ( tidyverse ) library ( modelr ) library ( modeldata ) Modelado b\u00e1sico Para este apartado, vamos a usar el conjunto de datos contenido en modeldata llamado \" oils \", que muestra las diferentes concentraciones de \u00e1cidos grasos en diferentes especies vegetales. 1 2 data ( oils ) View ( oils ) Para comenzar a modelar nos puede venir bien representar gr\u00e1ficamente los datos con los que queremos trabajar. Por ejemplo, imaginemos que necesitamos estudiar las concentraciones de \u00e1cido oleico con respecto a las de linoleico. Vamos a representar estas variables en un diagrama de dispersi\u00f3n: 1 2 ggplot ( data = oils ) + geom_point ( mapping = aes ( x = linoleic , y = oleic )) Vemos que hay una clara tendencia lineal entre las variables \\(y = a\u00b7x + b\\) . Para elegir la recta que mejor se ajusta, podemos generar multitud de ellas y elegirla al verla en la gr\u00e1fica. Para ello, debemos generar rectas \"aleatorias\", para lo cual podemos usar la funci\u00f3n runif() para generar pendientes y puntos de corte con \\(y\\) (es decir, \\(a\\) y \\(b\\) respectivamente) 1 runif ( < N\u00daMERO_DE_RECTAS > , min = , max = ) Generamos, por ejemplo, 200 rectas definiendo primero \\(a\\) y \\(b\\) . Viendo la gr\u00e1fica, podemos deducir el punto de corte con el eje alrededor de 80 (entre 77 y 83) y la pendiente alrededor de 1 (entre -2 y 2): 1 2 3 4 ayb <- tibble ( a = runif ( 200 , -2 , 2 ), b = runif ( 200 , 77 , 83 ) ) Tras lo cual, representamos tanto las variables como las rectas, para lo cual usamos la funci\u00f3n de ggplot2 geom_abline() : 1 geom_abline ( data = < DATOS > , aes ( slope = < PENDIENTE > , intercept = < CORTE_EJE_Y > )) 1 2 3 ggplot () + geom_abline ( data = ayb , mapping = aes ( slope = a , intercept = b ), alpha = 1 / 4 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Obtenemos algo parecido a esto: Vemos que la mayor\u00eda de l\u00edneas generadas est\u00e1n lejos de ajustarse a los datos. Para seleccionar las buenas es necesario calcular la distancia vertical entre los puntos y las l\u00edneas, para lo cual es necesario crear funciones. Este proceso es com\u00fan a la mayor\u00eda de diferentes modelados que podemos hacer sobre un set de datos. Este proceso puede ser tedioso y requiere de bastante experiencia en el tema, tarea a la cual el alumno de bioqu\u00edmica medio no est\u00e1 acostumbrado. Por ello, en este tutorial proponemos una forma de entrar en el mundo del modelado de datos sin tener que lidiar con programaci\u00f3n demasiado compleja. Modelado de regresi\u00f3n lineal Un buen punto de partida para comenzar a modelar consiste en crear tus propias regresiones lineales en R. Sin embargo, antes de comenzar siempre es necesario hacer un test de correlaci\u00f3n de Pearson sobre nuestros datos. Esto se hace f\u00e1cilmente empleando la funci\u00f3n cor.test() , de la siguiente forma: 1 cor.test ( x , y ) En nuestro caso, determinamos nuestras variables x e y indicando primero \" oils \" junto con el nombre de la variable empleando el s\u00edmbolo \" $ \": 1 cor.test ( oils $ oleic , oils $ linoleic ) 1 2 3 4 5 6 7 8 9 10 Pearson ' s product-moment correlation data : oils $ oleic and oils $ linoleic t = -45.185 , df = 94 , p - value < 2.2e-16 alternative hypothesis : true correlation is not equal to 0 95 percent confidence interval : -0.9851233 -0.9667696 sample estimates : cor -0.9777453 El coeficiente de correlaci\u00f3n cercano al valor -1 nos indica que existe una fuerte correlaci\u00f3n lineal negativa, y el p -valor menor que 0.05 se\u00f1ala que el modelo lineal es v\u00e1lido. Ahora podemos plantear un modelo de regresi\u00f3n lineal con seguridad. Para ello, vamos a usar la funci\u00f3n lm() . Esta funci\u00f3n se usa de forma muy similar a la anterior: 1 lm ( y ~ x ) Definimos una variable para el modelo linear de nuestras variables de la siguiente forma: 1 2 regresion <- lm ( oils $ oleic ~ oils $ linoleic ) View ( regresion ) Para continuar con el an\u00e1lisis, hacemos un summary() a nuestra nueva variable, obteniendo lo siguiente: 1 summary ( regresion ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Call : lm ( formula = oils $ oleic ~ oils $ linoleic ) Residuals : Min 1 Q Median 3 Q Max -7.1814 -1.6842 -0.0709 2.6859 5.0556 Coefficients : Estimate Std. Error t value Pr ( >| t | ) ( Intercept ) 79.35660 0.99614 79.66 < 2e-16 *** oils $ linoleic -0.91699 0.02029 -45.19 < 2e-16 *** --- Signif. codes : 0 \u2018 *** \u2019 0.001 \u2018 ** \u2019 0.01 \u2018 * \u2019 0.05 \u2018 . \u2019 0.1 \u2018 \u2019 1 Residual standard error : 3.133 on 94 degrees of freedom Multiple R - squared : 0.956 , Adjusted R - squared : 0.9555 F - statistic : 2042 on 1 and 94 DF , p - value : < 2.2e-16 Vemos como el R 2 obtenido es de 0.9555 , reafirmando la validez de nuestro modelo lineal. Podemos, finalmente, determinar cu\u00e1l es la l\u00ednea de ajuste de este conjunto de datos. Para ello, necesitamos los valores de pendiente y de corte con el eje y . Estos valores ya los hemos calculado al hacer el summary() , y se encuentran en el apartado coefficients : 1 regresion $ coefficients 1 2 ( Intercept ) oils $ linoleic 79.3565958 -0.9169897 Nota Adem\u00e1s de para encontrar modelos lineales, lm() sirve para realizar cualquier tipo de regresi\u00f3n, an\u00e1lisis de varianza y covarianza y otros c\u00e1lculos estad\u00edsticos. Puedes profundizar m\u00e1s en c\u00f3mo usar esta funci\u00f3n aqu\u00ed . El valor de (Intercept) es el punto de corte con el eje y oils$linoleic es la pendiente. Sustituyendo estos valores en la ecuaci\u00f3n de la recta \\(y = a\u00b7x + b\\) , obtenemos la l\u00ednea de regresi\u00f3n exacta para nuestros datos. Represent\u00e1ndola obtenemos: 1 2 a <- regresion $ coefficients [ 2 ] b <- regresion $ coefficients [ 1 ] 1 2 3 ggplot () + geom_abline ( mapping = aes ( slope = a , intercept = b ), color = \"red\" , size = 1 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Razona: Intenta a\u00f1adir un cuadro de texto en la gr\u00e1fica que el que se muestre la ecuaci\u00f3n de la recta de regresi\u00f3n y el R 2 . 1\u00aa Pista Prueba a utilizar el comando annotate() tras el resto de comandos geom . 2\u00aa Pista Usa el comando annotate() de la siguiente forma: 1 annotate ( \"text\" , x = < POSICI\u00d3N_X > , y = < POSICI\u00d3N_Y > , label = \"<TEXTO>\" ) Respuesta 1 2 3 4 ggplot () + geom_abline ( mapping = aes ( slope = a , intercept = b ), color = \"red\" , size = 1 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) + annotate ( \"text\" , x = c ( 50 , 50 ), y = c ( 50 , 46 ), label = c ( \"y = -0.917x + 79.4\" , \"R2 = 0.9555\" )) Otros modelados Como has podido observar, el modelado de datos, en definitiva, se trata de un proceso estad\u00edstico. En este tutorial hemos propuesto como ejemplo b\u00e1sico de modelado la regresi\u00f3n lineal, t\u00e9cnica muy empleada en cualquier rama de la ciencia. Evidentemente, existen muchos m\u00e1s tipos, y pueden enfocarse de maneras ilimitadas. Si sigues interesado en expandir tu conocimientos sobre este tema, te sugerimos que contin\u00faes con el apartado de modelado de \u201c R for Data Science \u201d, en concreto con el de interacci\u00f3n entre variables discretas y continuas . Ejercicios Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"modelar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja R for Data Science ; Hadley Wickham, Garrett Grolemund et al. Tidy Modeling with R ; Max Kuhn, Julia Silge lm function: Fitting Linear Models","title":"Modelar datos"},{"location":"modelar/#introduccion","text":"Modelar consiste en la aplicaci\u00f3n de herramientas matem\u00e1ticas para caracterizar un conjunto de datos y encontrar relaciones entre ellos, con las que somos capaces de: Predecir futuros resultados Encontrar patrones y diferencias entre variables Mejorar la visualizaci\u00f3n de los resultados A la hora de modelar, existen dos partes a seguir: Primero, debemos encontrar un patr\u00f3n dentro de los datos, que puede ser desde una relaci\u00f3n lineal simple \\(y = a\u00b7x + b\\) hasta una curva cuadr\u00e1tica \\(y = a\u00b7x^b\\) , siendo \\(x\\) e \\(y\\) las variables conocidas y \\(a\\) y \\(b\\) los par\u00e1metros que podemos modificar para encontrar la relaci\u00f3n. Tras esto, conociendo el patr\u00f3n, debemos encontrar el modelo que se ajusta a los datos (es decir, definir \\(a\\) y \\(b\\) ) Nota Hay que tener en cuenta que ning\u00fan modelo elegido es perfecto , simplemente es el que mejor se ajusta a los datos. Hay veces en el que el mejor modelo simplemente es malo y no tiene el por qu\u00e9 cumplirse en todos los casos. En esta parte del tutorial, adem\u00e1s de tidyverse , emplearemos el paquete modelr , incluido en R base y que nos dar\u00e1 algunas herramientas para comenzar a modelar. Adem\u00e1s, vamos a usar modeldata , que incluye una serie de conjuntos de datos preparados para aprender a modelar. Instalamos los paquetes y los cargamos: 1 install.packages ( \"modeldata\" ) 1 2 3 library ( tidyverse ) library ( modelr ) library ( modeldata )","title":"Introducci\u00f3n"},{"location":"modelar/#modelado-basico","text":"Para este apartado, vamos a usar el conjunto de datos contenido en modeldata llamado \" oils \", que muestra las diferentes concentraciones de \u00e1cidos grasos en diferentes especies vegetales. 1 2 data ( oils ) View ( oils ) Para comenzar a modelar nos puede venir bien representar gr\u00e1ficamente los datos con los que queremos trabajar. Por ejemplo, imaginemos que necesitamos estudiar las concentraciones de \u00e1cido oleico con respecto a las de linoleico. Vamos a representar estas variables en un diagrama de dispersi\u00f3n: 1 2 ggplot ( data = oils ) + geom_point ( mapping = aes ( x = linoleic , y = oleic )) Vemos que hay una clara tendencia lineal entre las variables \\(y = a\u00b7x + b\\) . Para elegir la recta que mejor se ajusta, podemos generar multitud de ellas y elegirla al verla en la gr\u00e1fica. Para ello, debemos generar rectas \"aleatorias\", para lo cual podemos usar la funci\u00f3n runif() para generar pendientes y puntos de corte con \\(y\\) (es decir, \\(a\\) y \\(b\\) respectivamente) 1 runif ( < N\u00daMERO_DE_RECTAS > , min = , max = ) Generamos, por ejemplo, 200 rectas definiendo primero \\(a\\) y \\(b\\) . Viendo la gr\u00e1fica, podemos deducir el punto de corte con el eje alrededor de 80 (entre 77 y 83) y la pendiente alrededor de 1 (entre -2 y 2): 1 2 3 4 ayb <- tibble ( a = runif ( 200 , -2 , 2 ), b = runif ( 200 , 77 , 83 ) ) Tras lo cual, representamos tanto las variables como las rectas, para lo cual usamos la funci\u00f3n de ggplot2 geom_abline() : 1 geom_abline ( data = < DATOS > , aes ( slope = < PENDIENTE > , intercept = < CORTE_EJE_Y > )) 1 2 3 ggplot () + geom_abline ( data = ayb , mapping = aes ( slope = a , intercept = b ), alpha = 1 / 4 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Obtenemos algo parecido a esto: Vemos que la mayor\u00eda de l\u00edneas generadas est\u00e1n lejos de ajustarse a los datos. Para seleccionar las buenas es necesario calcular la distancia vertical entre los puntos y las l\u00edneas, para lo cual es necesario crear funciones. Este proceso es com\u00fan a la mayor\u00eda de diferentes modelados que podemos hacer sobre un set de datos. Este proceso puede ser tedioso y requiere de bastante experiencia en el tema, tarea a la cual el alumno de bioqu\u00edmica medio no est\u00e1 acostumbrado. Por ello, en este tutorial proponemos una forma de entrar en el mundo del modelado de datos sin tener que lidiar con programaci\u00f3n demasiado compleja.","title":"Modelado b\u00e1sico"},{"location":"modelar/#modelado-de-regresion-lineal","text":"Un buen punto de partida para comenzar a modelar consiste en crear tus propias regresiones lineales en R. Sin embargo, antes de comenzar siempre es necesario hacer un test de correlaci\u00f3n de Pearson sobre nuestros datos. Esto se hace f\u00e1cilmente empleando la funci\u00f3n cor.test() , de la siguiente forma: 1 cor.test ( x , y ) En nuestro caso, determinamos nuestras variables x e y indicando primero \" oils \" junto con el nombre de la variable empleando el s\u00edmbolo \" $ \": 1 cor.test ( oils $ oleic , oils $ linoleic ) 1 2 3 4 5 6 7 8 9 10 Pearson ' s product-moment correlation data : oils $ oleic and oils $ linoleic t = -45.185 , df = 94 , p - value < 2.2e-16 alternative hypothesis : true correlation is not equal to 0 95 percent confidence interval : -0.9851233 -0.9667696 sample estimates : cor -0.9777453 El coeficiente de correlaci\u00f3n cercano al valor -1 nos indica que existe una fuerte correlaci\u00f3n lineal negativa, y el p -valor menor que 0.05 se\u00f1ala que el modelo lineal es v\u00e1lido. Ahora podemos plantear un modelo de regresi\u00f3n lineal con seguridad. Para ello, vamos a usar la funci\u00f3n lm() . Esta funci\u00f3n se usa de forma muy similar a la anterior: 1 lm ( y ~ x ) Definimos una variable para el modelo linear de nuestras variables de la siguiente forma: 1 2 regresion <- lm ( oils $ oleic ~ oils $ linoleic ) View ( regresion ) Para continuar con el an\u00e1lisis, hacemos un summary() a nuestra nueva variable, obteniendo lo siguiente: 1 summary ( regresion ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Call : lm ( formula = oils $ oleic ~ oils $ linoleic ) Residuals : Min 1 Q Median 3 Q Max -7.1814 -1.6842 -0.0709 2.6859 5.0556 Coefficients : Estimate Std. Error t value Pr ( >| t | ) ( Intercept ) 79.35660 0.99614 79.66 < 2e-16 *** oils $ linoleic -0.91699 0.02029 -45.19 < 2e-16 *** --- Signif. codes : 0 \u2018 *** \u2019 0.001 \u2018 ** \u2019 0.01 \u2018 * \u2019 0.05 \u2018 . \u2019 0.1 \u2018 \u2019 1 Residual standard error : 3.133 on 94 degrees of freedom Multiple R - squared : 0.956 , Adjusted R - squared : 0.9555 F - statistic : 2042 on 1 and 94 DF , p - value : < 2.2e-16 Vemos como el R 2 obtenido es de 0.9555 , reafirmando la validez de nuestro modelo lineal. Podemos, finalmente, determinar cu\u00e1l es la l\u00ednea de ajuste de este conjunto de datos. Para ello, necesitamos los valores de pendiente y de corte con el eje y . Estos valores ya los hemos calculado al hacer el summary() , y se encuentran en el apartado coefficients : 1 regresion $ coefficients 1 2 ( Intercept ) oils $ linoleic 79.3565958 -0.9169897 Nota Adem\u00e1s de para encontrar modelos lineales, lm() sirve para realizar cualquier tipo de regresi\u00f3n, an\u00e1lisis de varianza y covarianza y otros c\u00e1lculos estad\u00edsticos. Puedes profundizar m\u00e1s en c\u00f3mo usar esta funci\u00f3n aqu\u00ed . El valor de (Intercept) es el punto de corte con el eje y oils$linoleic es la pendiente. Sustituyendo estos valores en la ecuaci\u00f3n de la recta \\(y = a\u00b7x + b\\) , obtenemos la l\u00ednea de regresi\u00f3n exacta para nuestros datos. Represent\u00e1ndola obtenemos: 1 2 a <- regresion $ coefficients [ 2 ] b <- regresion $ coefficients [ 1 ] 1 2 3 ggplot () + geom_abline ( mapping = aes ( slope = a , intercept = b ), color = \"red\" , size = 1 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Razona: Intenta a\u00f1adir un cuadro de texto en la gr\u00e1fica que el que se muestre la ecuaci\u00f3n de la recta de regresi\u00f3n y el R 2 . 1\u00aa Pista Prueba a utilizar el comando annotate() tras el resto de comandos geom . 2\u00aa Pista Usa el comando annotate() de la siguiente forma: 1 annotate ( \"text\" , x = < POSICI\u00d3N_X > , y = < POSICI\u00d3N_Y > , label = \"<TEXTO>\" ) Respuesta 1 2 3 4 ggplot () + geom_abline ( mapping = aes ( slope = a , intercept = b ), color = \"red\" , size = 1 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) + annotate ( \"text\" , x = c ( 50 , 50 ), y = c ( 50 , 46 ), label = c ( \"y = -0.917x + 79.4\" , \"R2 = 0.9555\" ))","title":"Modelado de regresi\u00f3n lineal"},{"location":"modelar/#otros-modelados","text":"Como has podido observar, el modelado de datos, en definitiva, se trata de un proceso estad\u00edstico. En este tutorial hemos propuesto como ejemplo b\u00e1sico de modelado la regresi\u00f3n lineal, t\u00e9cnica muy empleada en cualquier rama de la ciencia. Evidentemente, existen muchos m\u00e1s tipos, y pueden enfocarse de maneras ilimitadas. Si sigues interesado en expandir tu conocimientos sobre este tema, te sugerimos que contin\u00faes con el apartado de modelado de \u201c R for Data Science \u201d, en concreto con el de interacci\u00f3n entre variables discretas y continuas .","title":"Otros modelados"},{"location":"modelar/#ejercicios","text":"Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"modelar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja R for Data Science ; Hadley Wickham, Garrett Grolemund et al. Tidy Modeling with R ; Max Kuhn, Julia Silge lm function: Fitting Linear Models","title":"Ejercicios"},{"location":"ordenar/","text":"Introducci\u00f3n Ahora que sabemos importar nuestros datos brutos, el siguiente paso es transformarlos en algo manejable. Para este apartado, vamos a usar nuestro propio set de datos: brca.txt , que contiene informaci\u00f3n anal\u00edtica sobre diferentes casos de c\u00e1ncer de mama, como por ejemplo la edad del paciente, subtipo cl\u00ednico, subtipo molecular, n\u00famero de ganglios linf\u00e1ticos, radioterapia, entre otros (puedes mirar todas las variables en el fichero original ). Adem\u00e1s, vamos a emplear un paquete de funciones nuevo, hablar , que no viene incluido ni en Tidyverse ni en R base. Este contiene una funci\u00f3n muy \u00fatil que nos permite cambiar el tipo de dato asignado a una variable , tema que trataremos m\u00e1s adelante en el tutorial (si necesitas obtener m\u00e1s informaci\u00f3n, lee el manual de referencia ). Lo instalamos y cargamos los paquetes Tidyverse y hablar : 1 install.packages ( \"hablar\" ) 1 2 library ( tidyverse ) library ( hablar ) Una vez cargados los paquetes y descargado el archivo (que emplea tabulaciones como delimitadores), lo abrimos y le asignamos una variable: 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver el dataset en la consola simplemente escribiendo el nombre de la variable: 1 datos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 11 x 1,098 attrib_name TCGA.3C.AAAU TCGA.3C.AALI TCGA.3C.AALJ TCGA.3C.AALK TCGA.4H.AAAK TCGA.5L.AAT0 < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_to_bir ~ 55 50 62 52 50 42 2 Tumor_purity 0.7886 0.6974 0.7666 0.6869 0.649 0.6501 3 pathologic_s ~ NA 2 2 1 3 2 4 histological ~ infiltratingl ~ infiltratingd ~ infiltratingd ~ infiltratingd ~ infiltrating ~ infiltrating ~ 5 number_of_ly ~ 4 1 1 0 4 0 6 gender female female female female female female 7 radiation_th ~ no yes no no no yes 8 race white blackorafrica ~ blackorafrica ~ blackorafrica ~ white white 9 ethnicity nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanico ~ hispanicorla ~ 10 Median_overa ~ 1 1 0 0 0 0 11 overall_surv ~ 4047 4005 1474 1448 348 1477 # ... with 1,091 more variables: TCGA.5L.AAT1 <chr>, TCGA.5T.A9QA <chr>, TCGA.A1.A0SB <chr>,... Para visualizarlos en forma de tabla empleamos: 1 View ( datos ) Debe aparecer algo similar a esto: Orientaci\u00f3n de los datos Para considerar que un conjunto de datos est\u00e1 correctamente ordenado, este debe cumplir al menos las siguientes tres reglas: Cada variable debe tener su propia columna Cada caso debe tener su propia fila Cada valor debe tener su propia celda Lo primero de lo que podemos darnos cuenta es que la orientaci\u00f3n de nuestro conjunto de datos es incorrecta , pues se muestran las variables en las filas y los diferentes casos en las columnas. Esto puede solucionarse f\u00e1cilmente transponiendo las filas y columnas. Sin embargo, Tidyverse no ofrece ninguna funci\u00f3n para transponer tibbles . Por tanto, tenemos que usar la funci\u00f3n t() , incluida en R base: 1 t ( datos ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [, 1 ] [, 2 ] [, 3 ] [, 4 ] attrib_name \"years_to_birth\" \"Tumor_purity\" \"pathologic_stage\" \"histological_type\" TCGA.3C.AAAU \"55\" \"0.7886\" NA \"infiltratinglobularcarcinoma\" TCGA.3C.AALI \"50\" \"0.6974\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALJ \"62\" \"0.7666\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALK \"52\" \"0.6869\" \"1\" \"infiltratingductalcarcinoma\" TCGA.4H.AAAK \"50\" \"0.649\" \"3\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT0 \"42\" \"0.6501\" \"2\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT1 \"63\" \"0.5553\" \"4\" \"infiltratinglobularcarcinoma\" TCGA.5T.A9QA \"52\" \"0.8368\" \"2\" \"other,specify\" TCGA.A1.A0SB \"70\" \"0.9328\" \"1\" \"other,specify\" TCGA.A1.A0SD \"59\" \"0.6906\" \"2\" \"infiltratingductalcarcinoma\" TCGA.A1.A0SE \"56\" \"0.7979\" \"1\" \"mixedhistology(pleasespecify)\" TCGA.A1.A0SF \"54\" \"0.7237\" \"2\" \"infiltratingductalcarcinoma\" ... Esta funci\u00f3n, sin embargo, transforma las tibbles en data frames de R est\u00e1ndar. Esto tambi\u00e9n puede solucionarse f\u00e1cilmente usando as_tibble() . Vamos a definir una nueva variable para diferenciar los datos originales (variable datos ) de los bien ordenados (variable brca ), con los que vamos a trabajar a partir de ahora: 1 brca <- as_tibble ( t ( datos ), rownames = NA ) # \"rownames = NA\" evita eliminar la columna de nombres Comprobamos como se encuentran ahora nuestros datos: 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 1,098 x 10 V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 * < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_t ~ Tumor_p ~ patholog ~ histologica ~ number_o ~ gender_and ~ radiati ~ ethnicity Median_ov ~ overall ~ 2 55 0.7886 NA infiltratin ~ 4 female / whi ~ no nothispa ~ 1 4047 3 50 0.6974 2 infiltratin ~ 1 female / bla ~ yes nothispa ~ 1 4005 4 62 0.7666 2 infiltratin ~ 1 female / bla ~ no nothispa ~ 0 1474 5 52 0.6869 1 infiltratin ~ 0 female / bla ~ no nothispa ~ 0 1448 6 50 0.649 3 infiltratin ~ 4 female / whi ~ no nothispa ~ 0 348 7 42 0.6501 2 infiltratin ~ 0 female / whi ~ yes hispanic ~ 0 1477 8 63 0.5553 4 infiltratin ~ 0 female / whi ~ no hispanic ~ 0 1471 9 52 0.8368 2 other , speci ~ NA female / bla ~ yes nothispa ~ 0 303 10 70 0.9328 1 other , speci ~ 0 female / whi ~ NA nothispa ~ 0 259 # ... with 1,088 more rows Vemos que esta funci\u00f3n ha asignado nombres predeterminados a las columnas traspuestas ( V1 , V2 , V3 ...), dejando los nombres originales en una fila aparte. Corregimos los nombres y eliminamos la fila sobrante de esta manera: 1 2 colnames ( brca ) <- brca [ 1 ,] # Cambia los nombres de las columnas brca <- brca [ -1 ,] # Elimina la fila que conten\u00eda los nombres 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Los datos quedar\u00edan finalmente de la siguiente forma: 1 View ( brca ) Importante: Vamos a usar estos datos modificados brca hasta el final del apartado. Es posible que alg\u00fan ejercicio no funcione si no hab\u00e9is seguido los pasos que hemos hecho hasta ahora. Modificar datos Ahora que los datos se encuentran bien orientados, es m\u00e1s f\u00e1cil ver los resultados y pensar qu\u00e9 modificaciones podemos hacer. Nota Ya hemos estudiado la manipulaci\u00f3n b\u00e1sica de data frames en el tutorial b\u00e1sico anterior. Puedes mirarlo aqu\u00ed . Combinar columnas Tidyverse ofrece una herramienta que nos permite unir variables en una sola columna en caso de que lo necesitemos. Para ello, empleamos el comando unite() , de la siguiente forma: 1 unite ( < DATOS > , < COL_NUEVA > , < COLUMNA1 > , < COLUMNA2 > , ... , sep = \"<SEPARADOR>\" ) Por ejemplo, imaginemos que necesitamos en una sola columna a edad del paciente y la pureza del tumor: 1 ejemplo1 <- unite ( brca , ejemplo1 , years_to_birth , Tumor_purity , sep = \" - \" ) 1 ejemplo1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 9 ejemplo1 pathologic_stage histological_type number_of_lymph_ ~ gender_and_race radiation_thera ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7 ~ NA infiltratinglobular ~ 4 female / white no 2 50 - 0.6 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ yes 3 62 - 0.7 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ no 4 52 - 0.6 ~ 1 infiltratingductalc ~ 0 female / blackorafr ~ no 5 50 - 0.6 ~ 3 infiltratinglobular ~ 4 female / white no 6 42 - 0.6 ~ 2 infiltratinglobular ~ 0 female / white yes 7 63 - 0.5 ~ 4 infiltratinglobular ~ 0 female / white no 8 52 - 0.8 ~ 2 other , specify NA female / blackorafr ~ yes 9 70 - 0.9 ~ 1 other , specify 0 female / white NA 10 59 - 0.6 ~ 2 infiltratingductalc ~ 0 female / white NA # ... with 1,087 more rows, and 3 more variables: ethnicity <chr>, Median_overall_survival <chr>, # overall_survival <chr> Si no queremos eliminar las columnas originales, a\u00f1adimos remove = FALSE al comando: 1 ejemplo2 <- unite ( brca , ejemplo2 , years_to_birth , Tumor_purity , sep = \" - \" , remove = FALSE ) 1 ejemplo2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 ejemplo2 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_no ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7886 55 0.7886 NA infiltratinglobularcarc ~ 4 2 50 - 0.6974 50 0.6974 2 infiltratingductalcarci ~ 1 3 62 - 0.7666 62 0.7666 2 infiltratingductalcarci ~ 1 4 52 - 0.6869 52 0.6869 1 infiltratingductalcarci ~ 0 5 50 - 0.649 50 0.649 3 infiltratinglobularcarc ~ 4 6 42 - 0.6501 42 0.6501 2 infiltratinglobularcarc ~ 0 7 63 - 0.5553 63 0.5553 4 infiltratinglobularcarc ~ 0 8 52 - 0.8368 52 0.8368 2 other , specify NA 9 70 - 0.9328 70 0.9328 1 other , specify 0 10 59 - 0.6906 59 0.6906 2 infiltratingductalcarci ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr> Ejercicio Prueba a combinar las variables pathologic_stage y radiation_therapy en una nueva columna llamada treatment_urgency , usando como separador \" & \" y sin eliminar las columnas originales. Respuesta 1 2 3 4 5 ejercicio1 <- unite ( brca , treatment_urgency , pathologic_stage , radiation_therapy , sep = \" & \" , remove = FALSE ) 1 ejercicio1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity treatment_urgency pathologic_stage histological_type number_of_lymph_ ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA & no NA infiltratinglobular ~ 4 2 50 0.6974 2 & yes 2 infiltratingductalc ~ 1 3 62 0.7666 2 & no 2 infiltratingductalc ~ 1 4 52 0.6869 1 & no 1 infiltratingductalc ~ 0 5 50 0.649 3 & no 3 infiltratinglobular ~ 4 6 42 0.6501 2 & yes 2 infiltratinglobular ~ 0 7 63 0.5553 4 & no 4 infiltratinglobular ~ 0 8 52 0.8368 2 & yes 2 other , specify NA 9 70 0.9328 1 & NA 1 other , specify 0 10 59 0.6906 2 & NA 2 infiltratingductalc ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr> Separar columnas De la misma forma, podemos separar variables en varias columnas f\u00e1cilmente empleando separate() : 1 separate ( < DATOS > , < NOMBRE_COLUMNA > , into = c ( \"<COL_NUEVA_1>\" , \"<COL_NUEVA_2>\" ), sep = \"<SEPARADOR>\" ) Esta funci\u00f3n es muy \u00fatil, pues permite separar las columnas empleando cualquier tipo de car\u00e1cter como separador. Por ejemplo, en nuestro set de datos encontramos las variables \"g\u00e9nero\" y \"raza\" en una misma columna llamada gender_and_race . Vamos a separarlas: 1 ejemplo3 <- separate ( brca , gender_and_race , into = c ( \"gender\" , \"race\" ), sep = \"/\" ) 1 ejemplo3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender race < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobular ~ 4 female white 2 50 0.6974 2 infiltratingductalc ~ 1 female blackoraf ~ 3 62 0.7666 2 infiltratingductalc ~ 1 female blackoraf ~ 4 52 0.6869 1 infiltratingductalc ~ 0 female blackoraf ~ 5 50 0.649 3 infiltratinglobular ~ 4 female white 6 42 0.6501 2 infiltratinglobular ~ 0 female white 7 63 0.5553 4 infiltratinglobular ~ 0 female white 8 52 0.8368 2 other , specify NA female blackoraf ~ 9 70 0.9328 1 other , specify 0 female white 10 59 0.6906 2 infiltratingductalc ~ 0 female white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Reordenar columnas Normalmente las variables se organizan de forma que aquellas que son m\u00e1s importantes se encuentran m\u00e1s hacia la izquierda. Trabajando podemos estimar que alguna variable es la m\u00e1s importante en nuestro caso y queremos que sea la que ocupa la primera columna. Esto es muy sencillo de arreglar empleando la funci\u00f3n relocate() , con la que podemos elegir la columna que queremos ver m\u00e1s a la izquierda : 1 relocate ( < DATOS > , < VARIABLE > ) Por ejemplo, mirando nuestros datos ordenados estimamos que la variable histological_type es la m\u00e1s importante para nuestro estudio. La reordenamos de la siguiente forma: 1 ejemplo4 <- relocate ( brca , histological_type ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 histological_type years_to_birth Tumor_purity pathologic_stage number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 infiltratinglobula ~ 55 0.7886 NA 4 female / white 2 infiltratingductal ~ 50 0.6974 2 1 female / blackorafr ~ 3 infiltratingductal ~ 62 0.7666 2 1 female / blackorafr ~ 4 infiltratingductal ~ 52 0.6869 1 0 female / blackorafr ~ 5 infiltratinglobula ~ 50 0.649 3 4 female / white 6 infiltratinglobula ~ 42 0.6501 2 0 female / white 7 infiltratinglobula ~ 63 0.5553 4 0 female / white 8 other , specify 52 0.8368 2 NA female / blackorafr ~ 9 other , specify 70 0.9328 1 0 female / white 10 infiltratingductal ~ 59 0.6906 2 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Ejercicio Con esta funci\u00f3n podemos colocar las columnas en las posiciones que queramos, no solamente en la primera columna. Intenta mover la variable ethnicity a la 3\u00aa columna. Pista 1 Puedes usar alguno de estos dos comandos dentro de relocate() : .before = o .after = . Pista 2 Trata de usar el comando de una de las siguientes formas: 1 2 3 relocate ( < DATOS > , < VARIABLE > , .before = < VARIABLE_ANTES > ) 1 2 3 relocate ( < DATOS > , < VARIABLE > , .after = < VARIABLE_DESPUES > ) Respuesta 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .before = pathologic_stage ) Tambi\u00e9n sirve: 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .after = Tumor_purity ) En ambos casos obtenemos: 1 ejercicio2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity ethnicity pathologic_stage histological_type number_of_lymph_n ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 nothispanicor ~ NA infiltratinglobularca ~ 4 2 50 0.6974 nothispanicor ~ 2 infiltratingductalcar ~ 1 3 62 0.7666 nothispanicor ~ 2 infiltratingductalcar ~ 1 4 52 0.6869 nothispanicor ~ 1 infiltratingductalcar ~ 0 5 50 0.649 nothispanicor ~ 3 infiltratinglobularca ~ 4 6 42 0.6501 hispanicorlat ~ 2 infiltratinglobularca ~ 0 7 63 0.5553 hispanicorlat ~ 4 infiltratinglobularca ~ 0 8 52 0.8368 nothispanicor ~ 2 other , specify NA 9 70 0.9328 nothispanicor ~ 1 other , specify 0 10 59 0.6906 nothispanicor ~ 2 infiltratingductalcar ~ 0 # ... with 1,087 more rows, and 4 more variables: gender_and_race <chr>, radiation_therapy <chr>, # Median_overall_survival <chr>, overall_survival <chr> Separar datos por factores En algunos casos vamos a necesitar separar nuestro set de datos en funci\u00f3n de una de sus variables tipo factor . Para ello, empleamos la funci\u00f3n split() : 1 split ( < DATOS > , < VARIABLES > ) En nuestro caso de ejemplo, imaginemos que necesitamos separar nuestros datos en diferentes tibbles en funci\u00f3n del tipo de tumor (variable histological_type ). Lo hacemos creando una variable de la siguiente forma: 1 tipo_tumor <- split ( brca , brca $ histological_type ) A esta variable se le asigna una lista similar a la siguiente: De este modo, podemos estudiar uno de los factores sin tener en cuenta los dem\u00e1s, Veamos, por ejemplo, \u00fanicamente los datos correspondientes a aquellos carcinomas de origen medular ( medullarycarcinoma ): 1 View ( tipo_tumor $ medullarycarcinoma ) Cambiar tipo de datos Al importar los datos, transformarlos a tibble y modificarlos hemos cambiado su naturaleza . Esto puede comprobarse debajo de los nombres de las columnas, donde vemos que las funciones de coversion asignadas no coinciden con el tipo de dato. Esto puede darnos problemas a la hora de realizar c\u00e1lculos estad\u00edsticos, modificaciones m\u00e1s complejas y representaciones gr\u00e1ficas, por lo que es conveniente transformarlos al tipo de dato correspondiente. Nota Es necesario antes conocer qu\u00e9 significan cada una de las funciones de conversi\u00f3n de datos. A continuaci\u00f3n, se muestran las m\u00e1s comunes: FUNCIONES TIPO DE DATO <chr> Car\u00e1cter <num> Num\u00e9rico <int> Entero <lgl> L\u00f3gico <fct> Factor <dte> Fecha <dtm> Fecha y hora <dbl> Decimales Usemos de nuevo nuestros datos. Muchas de nuestras variables son num\u00e9ricas. Sin embargo, a todas se les ha asignado el tipo car\u00e1cter. Podemos arreglar esto empleando la funci\u00f3n convert() , perteneciente al paquete de datos hablar : 1 convert ( < DATOS > , < FUNCI\u00d3N_CONVERSI\u00d3N > ( < COLUMNAS > )) Vemos que muchas de las variables ( years_to_birth , number_of_lymph_nodes , Median_overall_survival y overall_survival ) son n\u00fameros enteros ( <int> ) pero est\u00e1n clasificados como car\u00e1cter ( <chr> ). Arreglamos esto de forma sencilla: 1 2 3 4 5 6 7 ejemplo4 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ) ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < chr > < chr > < chr > < int > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> Podemos aplicar varios tipos de datos a diferentes variables. Por ejemplo, la variable Tumor_purity es una variable decimal ( <dbl> ): 1 2 3 4 5 6 7 8 9 10 11 ejemplo5 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ), dbl ( Tumor_purity ) ) 1 ejemplo5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < dbl > < chr > < chr > < int > < chr > 1 55 0.789 NA infiltratinglobula ~ 4 female / white 2 50 0.697 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.767 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.687 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.650 2 infiltratinglobula ~ 0 female / white 7 63 0.555 4 infiltratinglobula ~ 0 female / white 8 52 0.837 2 other , specify NA female / blackorafr ~ 9 70 0.933 1 other , specify 0 female / white 10 59 0.691 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> De esta forma hemos solucionado muchos problemas en el futuro por trabajar con datos err\u00f3neamente clasificados. Ejercicios Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"ordenar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Suppl. Ch. 2: Import and Tidy Data ; Gabriel Odom Data import: cheat sheet ; Garrett Grolemund Package \u2018hablar\u2019 ; David Sjoberg A grammer for data type conversion ; David Sjoberg Change column order: relocate LinkedOmics Data Download","title":"Ordenar datos"},{"location":"ordenar/#introduccion","text":"Ahora que sabemos importar nuestros datos brutos, el siguiente paso es transformarlos en algo manejable. Para este apartado, vamos a usar nuestro propio set de datos: brca.txt , que contiene informaci\u00f3n anal\u00edtica sobre diferentes casos de c\u00e1ncer de mama, como por ejemplo la edad del paciente, subtipo cl\u00ednico, subtipo molecular, n\u00famero de ganglios linf\u00e1ticos, radioterapia, entre otros (puedes mirar todas las variables en el fichero original ). Adem\u00e1s, vamos a emplear un paquete de funciones nuevo, hablar , que no viene incluido ni en Tidyverse ni en R base. Este contiene una funci\u00f3n muy \u00fatil que nos permite cambiar el tipo de dato asignado a una variable , tema que trataremos m\u00e1s adelante en el tutorial (si necesitas obtener m\u00e1s informaci\u00f3n, lee el manual de referencia ). Lo instalamos y cargamos los paquetes Tidyverse y hablar : 1 install.packages ( \"hablar\" ) 1 2 library ( tidyverse ) library ( hablar ) Una vez cargados los paquetes y descargado el archivo (que emplea tabulaciones como delimitadores), lo abrimos y le asignamos una variable: 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver el dataset en la consola simplemente escribiendo el nombre de la variable: 1 datos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 11 x 1,098 attrib_name TCGA.3C.AAAU TCGA.3C.AALI TCGA.3C.AALJ TCGA.3C.AALK TCGA.4H.AAAK TCGA.5L.AAT0 < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_to_bir ~ 55 50 62 52 50 42 2 Tumor_purity 0.7886 0.6974 0.7666 0.6869 0.649 0.6501 3 pathologic_s ~ NA 2 2 1 3 2 4 histological ~ infiltratingl ~ infiltratingd ~ infiltratingd ~ infiltratingd ~ infiltrating ~ infiltrating ~ 5 number_of_ly ~ 4 1 1 0 4 0 6 gender female female female female female female 7 radiation_th ~ no yes no no no yes 8 race white blackorafrica ~ blackorafrica ~ blackorafrica ~ white white 9 ethnicity nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanico ~ hispanicorla ~ 10 Median_overa ~ 1 1 0 0 0 0 11 overall_surv ~ 4047 4005 1474 1448 348 1477 # ... with 1,091 more variables: TCGA.5L.AAT1 <chr>, TCGA.5T.A9QA <chr>, TCGA.A1.A0SB <chr>,... Para visualizarlos en forma de tabla empleamos: 1 View ( datos ) Debe aparecer algo similar a esto:","title":"Introducci\u00f3n"},{"location":"ordenar/#orientacion-de-los-datos","text":"Para considerar que un conjunto de datos est\u00e1 correctamente ordenado, este debe cumplir al menos las siguientes tres reglas: Cada variable debe tener su propia columna Cada caso debe tener su propia fila Cada valor debe tener su propia celda Lo primero de lo que podemos darnos cuenta es que la orientaci\u00f3n de nuestro conjunto de datos es incorrecta , pues se muestran las variables en las filas y los diferentes casos en las columnas. Esto puede solucionarse f\u00e1cilmente transponiendo las filas y columnas. Sin embargo, Tidyverse no ofrece ninguna funci\u00f3n para transponer tibbles . Por tanto, tenemos que usar la funci\u00f3n t() , incluida en R base: 1 t ( datos ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [, 1 ] [, 2 ] [, 3 ] [, 4 ] attrib_name \"years_to_birth\" \"Tumor_purity\" \"pathologic_stage\" \"histological_type\" TCGA.3C.AAAU \"55\" \"0.7886\" NA \"infiltratinglobularcarcinoma\" TCGA.3C.AALI \"50\" \"0.6974\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALJ \"62\" \"0.7666\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALK \"52\" \"0.6869\" \"1\" \"infiltratingductalcarcinoma\" TCGA.4H.AAAK \"50\" \"0.649\" \"3\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT0 \"42\" \"0.6501\" \"2\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT1 \"63\" \"0.5553\" \"4\" \"infiltratinglobularcarcinoma\" TCGA.5T.A9QA \"52\" \"0.8368\" \"2\" \"other,specify\" TCGA.A1.A0SB \"70\" \"0.9328\" \"1\" \"other,specify\" TCGA.A1.A0SD \"59\" \"0.6906\" \"2\" \"infiltratingductalcarcinoma\" TCGA.A1.A0SE \"56\" \"0.7979\" \"1\" \"mixedhistology(pleasespecify)\" TCGA.A1.A0SF \"54\" \"0.7237\" \"2\" \"infiltratingductalcarcinoma\" ... Esta funci\u00f3n, sin embargo, transforma las tibbles en data frames de R est\u00e1ndar. Esto tambi\u00e9n puede solucionarse f\u00e1cilmente usando as_tibble() . Vamos a definir una nueva variable para diferenciar los datos originales (variable datos ) de los bien ordenados (variable brca ), con los que vamos a trabajar a partir de ahora: 1 brca <- as_tibble ( t ( datos ), rownames = NA ) # \"rownames = NA\" evita eliminar la columna de nombres Comprobamos como se encuentran ahora nuestros datos: 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 1,098 x 10 V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 * < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_t ~ Tumor_p ~ patholog ~ histologica ~ number_o ~ gender_and ~ radiati ~ ethnicity Median_ov ~ overall ~ 2 55 0.7886 NA infiltratin ~ 4 female / whi ~ no nothispa ~ 1 4047 3 50 0.6974 2 infiltratin ~ 1 female / bla ~ yes nothispa ~ 1 4005 4 62 0.7666 2 infiltratin ~ 1 female / bla ~ no nothispa ~ 0 1474 5 52 0.6869 1 infiltratin ~ 0 female / bla ~ no nothispa ~ 0 1448 6 50 0.649 3 infiltratin ~ 4 female / whi ~ no nothispa ~ 0 348 7 42 0.6501 2 infiltratin ~ 0 female / whi ~ yes hispanic ~ 0 1477 8 63 0.5553 4 infiltratin ~ 0 female / whi ~ no hispanic ~ 0 1471 9 52 0.8368 2 other , speci ~ NA female / bla ~ yes nothispa ~ 0 303 10 70 0.9328 1 other , speci ~ 0 female / whi ~ NA nothispa ~ 0 259 # ... with 1,088 more rows Vemos que esta funci\u00f3n ha asignado nombres predeterminados a las columnas traspuestas ( V1 , V2 , V3 ...), dejando los nombres originales en una fila aparte. Corregimos los nombres y eliminamos la fila sobrante de esta manera: 1 2 colnames ( brca ) <- brca [ 1 ,] # Cambia los nombres de las columnas brca <- brca [ -1 ,] # Elimina la fila que conten\u00eda los nombres 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Los datos quedar\u00edan finalmente de la siguiente forma: 1 View ( brca ) Importante: Vamos a usar estos datos modificados brca hasta el final del apartado. Es posible que alg\u00fan ejercicio no funcione si no hab\u00e9is seguido los pasos que hemos hecho hasta ahora.","title":"Orientaci\u00f3n de los datos"},{"location":"ordenar/#modificar-datos","text":"Ahora que los datos se encuentran bien orientados, es m\u00e1s f\u00e1cil ver los resultados y pensar qu\u00e9 modificaciones podemos hacer. Nota Ya hemos estudiado la manipulaci\u00f3n b\u00e1sica de data frames en el tutorial b\u00e1sico anterior. Puedes mirarlo aqu\u00ed .","title":"Modificar datos"},{"location":"ordenar/#combinar-columnas","text":"Tidyverse ofrece una herramienta que nos permite unir variables en una sola columna en caso de que lo necesitemos. Para ello, empleamos el comando unite() , de la siguiente forma: 1 unite ( < DATOS > , < COL_NUEVA > , < COLUMNA1 > , < COLUMNA2 > , ... , sep = \"<SEPARADOR>\" ) Por ejemplo, imaginemos que necesitamos en una sola columna a edad del paciente y la pureza del tumor: 1 ejemplo1 <- unite ( brca , ejemplo1 , years_to_birth , Tumor_purity , sep = \" - \" ) 1 ejemplo1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 9 ejemplo1 pathologic_stage histological_type number_of_lymph_ ~ gender_and_race radiation_thera ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7 ~ NA infiltratinglobular ~ 4 female / white no 2 50 - 0.6 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ yes 3 62 - 0.7 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ no 4 52 - 0.6 ~ 1 infiltratingductalc ~ 0 female / blackorafr ~ no 5 50 - 0.6 ~ 3 infiltratinglobular ~ 4 female / white no 6 42 - 0.6 ~ 2 infiltratinglobular ~ 0 female / white yes 7 63 - 0.5 ~ 4 infiltratinglobular ~ 0 female / white no 8 52 - 0.8 ~ 2 other , specify NA female / blackorafr ~ yes 9 70 - 0.9 ~ 1 other , specify 0 female / white NA 10 59 - 0.6 ~ 2 infiltratingductalc ~ 0 female / white NA # ... with 1,087 more rows, and 3 more variables: ethnicity <chr>, Median_overall_survival <chr>, # overall_survival <chr> Si no queremos eliminar las columnas originales, a\u00f1adimos remove = FALSE al comando: 1 ejemplo2 <- unite ( brca , ejemplo2 , years_to_birth , Tumor_purity , sep = \" - \" , remove = FALSE ) 1 ejemplo2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 ejemplo2 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_no ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7886 55 0.7886 NA infiltratinglobularcarc ~ 4 2 50 - 0.6974 50 0.6974 2 infiltratingductalcarci ~ 1 3 62 - 0.7666 62 0.7666 2 infiltratingductalcarci ~ 1 4 52 - 0.6869 52 0.6869 1 infiltratingductalcarci ~ 0 5 50 - 0.649 50 0.649 3 infiltratinglobularcarc ~ 4 6 42 - 0.6501 42 0.6501 2 infiltratinglobularcarc ~ 0 7 63 - 0.5553 63 0.5553 4 infiltratinglobularcarc ~ 0 8 52 - 0.8368 52 0.8368 2 other , specify NA 9 70 - 0.9328 70 0.9328 1 other , specify 0 10 59 - 0.6906 59 0.6906 2 infiltratingductalcarci ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr> Ejercicio Prueba a combinar las variables pathologic_stage y radiation_therapy en una nueva columna llamada treatment_urgency , usando como separador \" & \" y sin eliminar las columnas originales. Respuesta 1 2 3 4 5 ejercicio1 <- unite ( brca , treatment_urgency , pathologic_stage , radiation_therapy , sep = \" & \" , remove = FALSE ) 1 ejercicio1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity treatment_urgency pathologic_stage histological_type number_of_lymph_ ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA & no NA infiltratinglobular ~ 4 2 50 0.6974 2 & yes 2 infiltratingductalc ~ 1 3 62 0.7666 2 & no 2 infiltratingductalc ~ 1 4 52 0.6869 1 & no 1 infiltratingductalc ~ 0 5 50 0.649 3 & no 3 infiltratinglobular ~ 4 6 42 0.6501 2 & yes 2 infiltratinglobular ~ 0 7 63 0.5553 4 & no 4 infiltratinglobular ~ 0 8 52 0.8368 2 & yes 2 other , specify NA 9 70 0.9328 1 & NA 1 other , specify 0 10 59 0.6906 2 & NA 2 infiltratingductalc ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr>","title":"Combinar columnas"},{"location":"ordenar/#separar-columnas","text":"De la misma forma, podemos separar variables en varias columnas f\u00e1cilmente empleando separate() : 1 separate ( < DATOS > , < NOMBRE_COLUMNA > , into = c ( \"<COL_NUEVA_1>\" , \"<COL_NUEVA_2>\" ), sep = \"<SEPARADOR>\" ) Esta funci\u00f3n es muy \u00fatil, pues permite separar las columnas empleando cualquier tipo de car\u00e1cter como separador. Por ejemplo, en nuestro set de datos encontramos las variables \"g\u00e9nero\" y \"raza\" en una misma columna llamada gender_and_race . Vamos a separarlas: 1 ejemplo3 <- separate ( brca , gender_and_race , into = c ( \"gender\" , \"race\" ), sep = \"/\" ) 1 ejemplo3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender race < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobular ~ 4 female white 2 50 0.6974 2 infiltratingductalc ~ 1 female blackoraf ~ 3 62 0.7666 2 infiltratingductalc ~ 1 female blackoraf ~ 4 52 0.6869 1 infiltratingductalc ~ 0 female blackoraf ~ 5 50 0.649 3 infiltratinglobular ~ 4 female white 6 42 0.6501 2 infiltratinglobular ~ 0 female white 7 63 0.5553 4 infiltratinglobular ~ 0 female white 8 52 0.8368 2 other , specify NA female blackoraf ~ 9 70 0.9328 1 other , specify 0 female white 10 59 0.6906 2 infiltratingductalc ~ 0 female white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr>","title":"Separar columnas"},{"location":"ordenar/#reordenar-columnas","text":"Normalmente las variables se organizan de forma que aquellas que son m\u00e1s importantes se encuentran m\u00e1s hacia la izquierda. Trabajando podemos estimar que alguna variable es la m\u00e1s importante en nuestro caso y queremos que sea la que ocupa la primera columna. Esto es muy sencillo de arreglar empleando la funci\u00f3n relocate() , con la que podemos elegir la columna que queremos ver m\u00e1s a la izquierda : 1 relocate ( < DATOS > , < VARIABLE > ) Por ejemplo, mirando nuestros datos ordenados estimamos que la variable histological_type es la m\u00e1s importante para nuestro estudio. La reordenamos de la siguiente forma: 1 ejemplo4 <- relocate ( brca , histological_type ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 histological_type years_to_birth Tumor_purity pathologic_stage number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 infiltratinglobula ~ 55 0.7886 NA 4 female / white 2 infiltratingductal ~ 50 0.6974 2 1 female / blackorafr ~ 3 infiltratingductal ~ 62 0.7666 2 1 female / blackorafr ~ 4 infiltratingductal ~ 52 0.6869 1 0 female / blackorafr ~ 5 infiltratinglobula ~ 50 0.649 3 4 female / white 6 infiltratinglobula ~ 42 0.6501 2 0 female / white 7 infiltratinglobula ~ 63 0.5553 4 0 female / white 8 other , specify 52 0.8368 2 NA female / blackorafr ~ 9 other , specify 70 0.9328 1 0 female / white 10 infiltratingductal ~ 59 0.6906 2 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Ejercicio Con esta funci\u00f3n podemos colocar las columnas en las posiciones que queramos, no solamente en la primera columna. Intenta mover la variable ethnicity a la 3\u00aa columna. Pista 1 Puedes usar alguno de estos dos comandos dentro de relocate() : .before = o .after = . Pista 2 Trata de usar el comando de una de las siguientes formas: 1 2 3 relocate ( < DATOS > , < VARIABLE > , .before = < VARIABLE_ANTES > ) 1 2 3 relocate ( < DATOS > , < VARIABLE > , .after = < VARIABLE_DESPUES > ) Respuesta 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .before = pathologic_stage ) Tambi\u00e9n sirve: 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .after = Tumor_purity ) En ambos casos obtenemos: 1 ejercicio2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity ethnicity pathologic_stage histological_type number_of_lymph_n ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 nothispanicor ~ NA infiltratinglobularca ~ 4 2 50 0.6974 nothispanicor ~ 2 infiltratingductalcar ~ 1 3 62 0.7666 nothispanicor ~ 2 infiltratingductalcar ~ 1 4 52 0.6869 nothispanicor ~ 1 infiltratingductalcar ~ 0 5 50 0.649 nothispanicor ~ 3 infiltratinglobularca ~ 4 6 42 0.6501 hispanicorlat ~ 2 infiltratinglobularca ~ 0 7 63 0.5553 hispanicorlat ~ 4 infiltratinglobularca ~ 0 8 52 0.8368 nothispanicor ~ 2 other , specify NA 9 70 0.9328 nothispanicor ~ 1 other , specify 0 10 59 0.6906 nothispanicor ~ 2 infiltratingductalcar ~ 0 # ... with 1,087 more rows, and 4 more variables: gender_and_race <chr>, radiation_therapy <chr>, # Median_overall_survival <chr>, overall_survival <chr>","title":"Reordenar columnas"},{"location":"ordenar/#separar-datos-por-factores","text":"En algunos casos vamos a necesitar separar nuestro set de datos en funci\u00f3n de una de sus variables tipo factor . Para ello, empleamos la funci\u00f3n split() : 1 split ( < DATOS > , < VARIABLES > ) En nuestro caso de ejemplo, imaginemos que necesitamos separar nuestros datos en diferentes tibbles en funci\u00f3n del tipo de tumor (variable histological_type ). Lo hacemos creando una variable de la siguiente forma: 1 tipo_tumor <- split ( brca , brca $ histological_type ) A esta variable se le asigna una lista similar a la siguiente: De este modo, podemos estudiar uno de los factores sin tener en cuenta los dem\u00e1s, Veamos, por ejemplo, \u00fanicamente los datos correspondientes a aquellos carcinomas de origen medular ( medullarycarcinoma ): 1 View ( tipo_tumor $ medullarycarcinoma )","title":"Separar datos por factores"},{"location":"ordenar/#cambiar-tipo-de-datos","text":"Al importar los datos, transformarlos a tibble y modificarlos hemos cambiado su naturaleza . Esto puede comprobarse debajo de los nombres de las columnas, donde vemos que las funciones de coversion asignadas no coinciden con el tipo de dato. Esto puede darnos problemas a la hora de realizar c\u00e1lculos estad\u00edsticos, modificaciones m\u00e1s complejas y representaciones gr\u00e1ficas, por lo que es conveniente transformarlos al tipo de dato correspondiente. Nota Es necesario antes conocer qu\u00e9 significan cada una de las funciones de conversi\u00f3n de datos. A continuaci\u00f3n, se muestran las m\u00e1s comunes: FUNCIONES TIPO DE DATO <chr> Car\u00e1cter <num> Num\u00e9rico <int> Entero <lgl> L\u00f3gico <fct> Factor <dte> Fecha <dtm> Fecha y hora <dbl> Decimales Usemos de nuevo nuestros datos. Muchas de nuestras variables son num\u00e9ricas. Sin embargo, a todas se les ha asignado el tipo car\u00e1cter. Podemos arreglar esto empleando la funci\u00f3n convert() , perteneciente al paquete de datos hablar : 1 convert ( < DATOS > , < FUNCI\u00d3N_CONVERSI\u00d3N > ( < COLUMNAS > )) Vemos que muchas de las variables ( years_to_birth , number_of_lymph_nodes , Median_overall_survival y overall_survival ) son n\u00fameros enteros ( <int> ) pero est\u00e1n clasificados como car\u00e1cter ( <chr> ). Arreglamos esto de forma sencilla: 1 2 3 4 5 6 7 ejemplo4 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ) ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < chr > < chr > < chr > < int > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> Podemos aplicar varios tipos de datos a diferentes variables. Por ejemplo, la variable Tumor_purity es una variable decimal ( <dbl> ): 1 2 3 4 5 6 7 8 9 10 11 ejemplo5 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ), dbl ( Tumor_purity ) ) 1 ejemplo5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < dbl > < chr > < chr > < int > < chr > 1 55 0.789 NA infiltratinglobula ~ 4 female / white 2 50 0.697 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.767 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.687 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.650 2 infiltratinglobula ~ 0 female / white 7 63 0.555 4 infiltratinglobula ~ 0 female / white 8 52 0.837 2 other , specify NA female / blackorafr ~ 9 70 0.933 1 other , specify 0 female / white 10 59 0.691 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> De esta forma hemos solucionado muchos problemas en el futuro por trabajar con datos err\u00f3neamente clasificados.","title":"Cambiar tipo de datos"},{"location":"ordenar/#ejercicios","text":"Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"ordenar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Suppl. Ch. 2: Import and Tidy Data ; Gabriel Odom Data import: cheat sheet ; Garrett Grolemund Package \u2018hablar\u2019 ; David Sjoberg A grammer for data type conversion ; David Sjoberg Change column order: relocate LinkedOmics Data Download","title":"Ejercicios"},{"location":"tidyverse/","text":"Introducci\u00f3n a Tidyverse Uno de los principales problemas con los que va a encontrarse cualquier bioqu\u00edmico en su \u00e1mbito laboral se da a la hora de abordar enormes cantidades de informaci\u00f3n, obtenida tras un an\u00e1lisis o captura de datos. A partir de estos datos sin procesar, muy dif\u00edcilmente se puede asimilar cu\u00e1l ha sido el resultado de este estudio, siendo ya imposible llegar a cualquier tipo de conclusi\u00f3n. Para poder utilizar estos datos, es necesario digerirlos , es decir, debemos ordenarlos, organizarlos, realizar las transformaciones necesarias y representarlos de alguna manera, de forma que seamos capaces de interpretarlos. La disciplina encargada de transformar estos datos \"crudos\" indescifrables en conocimiento aplicable es la ciencia de datos , con la que se es capaz de generar muchas posibles hip\u00f3tesis que explorar en profundidad. Existen numerosas herramientas inform\u00e1ticas (software, paquetes de funciones, etc.) a disposici\u00f3n del investigador para llevar a cabo esta tarea. En un principio, para un bioqu\u00edmico con poca experiencia en el an\u00e1lisis inform\u00e1tico de datos, es complicado saber por cu\u00e1l de estas herramientas empezar. La ciencia de datos es una disciplina extens\u00edsima, y no existe una sola forma \"correcta\" de entrar en este mundo. En este tutorial vamos a introducir al alumno en esta materia con Tidyverse . \u00bfQu\u00e9 es Tidyverse ? Tidyverse es una colecci\u00f3n de paquetes de R de c\u00f3digo abierto especialiados en la importaci\u00f3n, ordenamiento, modificaci\u00f3n y visualizaci\u00f3n de datos . Sus estructuras son muy similares, de forma que existe coherencia e integraci\u00f3n entre ellos, optimizando as\u00ed la aplicaci\u00f3n de sus funciones en la ciencia de datos . Estos paquetes y sus funciones son los mostrados a continuaci\u00f3n: PAQUETE DESCRIPCI\u00d3N readr Facilita la importaci\u00f3n de datos tibble Crea variaciones de los data frames est\u00e1ndar de R tidyr Contiene funciones para el reordenamiento de datos dplyr Contiene funciones para modificar data frames purrr Programaci\u00f3n funcional de datos ggplot2 Visualizaci\u00f3n de datos Veremos la funci\u00f3n de cada uno de estos paquetes en profundidad a lo largo de este tutorial. El flujo de trabajo en la ciencia de datos El flujo de trabajo normal durante el manejo de datos puede seguir el siguiente esquema: En primer lugar, debes importar tus datos a R. Una vez dentro, debes ordenarlos de forma consistente (suele ser una buena referencia inicial tener una variable por columna y una observaci\u00f3n por fila ), permiti\u00e9ndote empezar a encontrar relaciones. Los datos ordenados todav\u00eda no muestran f\u00e1cilmente toda la informaci\u00f3n que contienen. Primero es necesario entender su contexto. Para ello, debemos seguir un proceso de transformaci\u00f3n, visualizaci\u00f3n y modelado de la informaci\u00f3n. Transformar permite centrarnos en nuestras variables de inter\u00e9s y crear otras nuevas. Visualizar significa \"ver\" los resultados de forma m\u00e1s clara y natural, pudiendo encontrar respuestas a nuestras preguntas o resultados inesperados que nos hagan formular nuevas cuestiones. Modelar es buscar una interpretaci\u00f3n matem\u00e1tica o computacional que expliquen los resultados obtenidos, de forma que podamos obtener nuevas referencias y suposiciones, de forma que podamos retomar los datos desde otra perspectiva y resolver el problema. Finalmente, tras obtener los resultados finales, comunicamos los resultados. Adem\u00e1s, rodeando todos estos procesos encontramos la programaci\u00f3n , que es la herramienta que empleamos durante todo el proyecto. Requisitos previos Para empezar a utilizar Tidyverse , es necesario tener instalado R y RStudio (puedes encontrar ayuda sobre c\u00f3mo instalar y manejar RStudio ). Una vez instalados, ejecutamos el siguiente comando en la consola de RStudio: 1 install.packages ( \"tidyverse\" ) Ahora tendremos el paquete instalado y listo para usar. Para activarlo, ejecutamos el comando a continuaci\u00f3n: 1 library ( \"tidyverse\" ) Tras esto, Tidyverse est\u00e1 listo para usarse. Es importante ejecutar este \u00faltimo comando al inicio de cada nueva sesi\u00f3n. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Tidyverse; R packages for data science ; Hadley Wickham, Garrett Grolemund et al. R for Data Science ; Hadley Wickham, Garrett Grolemund et al.","title":"Tidyverse"},{"location":"tidyverse/#introduccion-a-tidyverse","text":"Uno de los principales problemas con los que va a encontrarse cualquier bioqu\u00edmico en su \u00e1mbito laboral se da a la hora de abordar enormes cantidades de informaci\u00f3n, obtenida tras un an\u00e1lisis o captura de datos. A partir de estos datos sin procesar, muy dif\u00edcilmente se puede asimilar cu\u00e1l ha sido el resultado de este estudio, siendo ya imposible llegar a cualquier tipo de conclusi\u00f3n. Para poder utilizar estos datos, es necesario digerirlos , es decir, debemos ordenarlos, organizarlos, realizar las transformaciones necesarias y representarlos de alguna manera, de forma que seamos capaces de interpretarlos. La disciplina encargada de transformar estos datos \"crudos\" indescifrables en conocimiento aplicable es la ciencia de datos , con la que se es capaz de generar muchas posibles hip\u00f3tesis que explorar en profundidad. Existen numerosas herramientas inform\u00e1ticas (software, paquetes de funciones, etc.) a disposici\u00f3n del investigador para llevar a cabo esta tarea. En un principio, para un bioqu\u00edmico con poca experiencia en el an\u00e1lisis inform\u00e1tico de datos, es complicado saber por cu\u00e1l de estas herramientas empezar. La ciencia de datos es una disciplina extens\u00edsima, y no existe una sola forma \"correcta\" de entrar en este mundo. En este tutorial vamos a introducir al alumno en esta materia con Tidyverse .","title":"Introducci\u00f3n a Tidyverse"},{"location":"tidyverse/#que-es-tidyverse","text":"Tidyverse es una colecci\u00f3n de paquetes de R de c\u00f3digo abierto especialiados en la importaci\u00f3n, ordenamiento, modificaci\u00f3n y visualizaci\u00f3n de datos . Sus estructuras son muy similares, de forma que existe coherencia e integraci\u00f3n entre ellos, optimizando as\u00ed la aplicaci\u00f3n de sus funciones en la ciencia de datos . Estos paquetes y sus funciones son los mostrados a continuaci\u00f3n: PAQUETE DESCRIPCI\u00d3N readr Facilita la importaci\u00f3n de datos tibble Crea variaciones de los data frames est\u00e1ndar de R tidyr Contiene funciones para el reordenamiento de datos dplyr Contiene funciones para modificar data frames purrr Programaci\u00f3n funcional de datos ggplot2 Visualizaci\u00f3n de datos Veremos la funci\u00f3n de cada uno de estos paquetes en profundidad a lo largo de este tutorial.","title":"\u00bfQu\u00e9 es Tidyverse?"},{"location":"tidyverse/#el-flujo-de-trabajo-en-la-ciencia-de-datos","text":"El flujo de trabajo normal durante el manejo de datos puede seguir el siguiente esquema: En primer lugar, debes importar tus datos a R. Una vez dentro, debes ordenarlos de forma consistente (suele ser una buena referencia inicial tener una variable por columna y una observaci\u00f3n por fila ), permiti\u00e9ndote empezar a encontrar relaciones. Los datos ordenados todav\u00eda no muestran f\u00e1cilmente toda la informaci\u00f3n que contienen. Primero es necesario entender su contexto. Para ello, debemos seguir un proceso de transformaci\u00f3n, visualizaci\u00f3n y modelado de la informaci\u00f3n. Transformar permite centrarnos en nuestras variables de inter\u00e9s y crear otras nuevas. Visualizar significa \"ver\" los resultados de forma m\u00e1s clara y natural, pudiendo encontrar respuestas a nuestras preguntas o resultados inesperados que nos hagan formular nuevas cuestiones. Modelar es buscar una interpretaci\u00f3n matem\u00e1tica o computacional que expliquen los resultados obtenidos, de forma que podamos obtener nuevas referencias y suposiciones, de forma que podamos retomar los datos desde otra perspectiva y resolver el problema. Finalmente, tras obtener los resultados finales, comunicamos los resultados. Adem\u00e1s, rodeando todos estos procesos encontramos la programaci\u00f3n , que es la herramienta que empleamos durante todo el proyecto.","title":"El flujo de trabajo en la ciencia de datos"},{"location":"tidyverse/#requisitos-previos","text":"Para empezar a utilizar Tidyverse , es necesario tener instalado R y RStudio (puedes encontrar ayuda sobre c\u00f3mo instalar y manejar RStudio ). Una vez instalados, ejecutamos el siguiente comando en la consola de RStudio: 1 install.packages ( \"tidyverse\" ) Ahora tendremos el paquete instalado y listo para usar. Para activarlo, ejecutamos el comando a continuaci\u00f3n: 1 library ( \"tidyverse\" ) Tras esto, Tidyverse est\u00e1 listo para usarse. Es importante ejecutar este \u00faltimo comando al inicio de cada nueva sesi\u00f3n. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Tidyverse; R packages for data science ; Hadley Wickham, Garrett Grolemund et al. R for Data Science ; Hadley Wickham, Garrett Grolemund et al.","title":"Requisitos previos"},{"location":"visualizar/","text":"Visualizaci\u00f3n de datos Introducci\u00f3n Es innegable que la ciencia de datos, sobre todo para los reci\u00e9n llegados, puede resultar un poco \"dif\u00edcil y aburrida\". Podemos deducir del esquema del apartado anterior que, a la hora de entrar en la ciencia de datos, lo mejor es empezar por el principio, es decir, importar, ordenar y transformar los datos. Sin embargo, esta tarea puede ser un poco frustrante. Tidyverse , por tanto, propone comenzar el estudio de esta disciplina por la parte de visualizaci\u00f3n de datos que ya han sido ordenados y transformados, tarea mucho m\u00e1s amigable para los principiantes. El paquete de Tidyverse encargado de la generaci\u00f3n de gr\u00e1ficas es ggplot2 . Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse ) En la consola veremos el siguiente mensaje: 1 2 3 4 5 6 7 8 #> \u2500\u2500 Attaching packages \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse 1.3.0 \u2500\u2500 #> \u2714 ggplot2 3.3.2 \u2714 purrr 0.3.4 #> \u2714 tibble 3.0.3 \u2714 dplyr 1.0.2 #> \u2714 tidyr 1.1.2 \u2714 stringr 1.4.0 #> \u2714 readr 1.4.0 \u2714 forcats 0.5.0 #> \u2500\u2500 Conflicts \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse_conflicts() \u2500\u2500 #> \u2716 dplyr::filter() masks stats::filter() #> \u2716 dplyr::lag() masks stats::lag() Nota Activaremos Tidyverse cada vez que iniciemos una nueva sesi\u00f3n en RStudio. Podemos ver, adem\u00e1s, como hay algunos paquetes en conflicto con otras funciones de R base, pero eso no importa demasiado. ggplot2 , junto con el resto de paquetes de Tidyverse , est\u00e1 activo y listo para graficar con \u00e9l. Como todav\u00eda no sabemos importar nuestros propios datos a Tidyverse , vamos a usar una serie de conjuntos de datos incluidos de serie en este paquete, con los que podemos practicar. Podemos ver uno de ellos con el comando mpg : 1 mpg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class < chr > < chr > < dbl > < int > < int > < chr > < chr > < int > < int > < chr > < chr > 1 audi a4 1.8 1999 4 auto ( l5 ) f 18 29 p compact 2 audi a4 1.8 1999 4 manual ( m5 ) f 21 29 p compact 3 audi a4 2 2008 4 manual ( m6 ) f 20 31 p compact 4 audi a4 2 2008 4 auto ( av ) f 21 30 p compact 5 audi a4 2.8 1999 6 auto ( l5 ) f 16 26 p compact 6 audi a4 2.8 1999 6 manual ( m5 ) f 18 26 p compact 7 audi a4 3.1 2008 6 auto ( av ) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual ( m5 ) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto ( l5 ) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual ( m6 ) 4 20 28 p compact # ... with 224 more rows Razona: \u00bfC\u00f3mo podr\u00edas mostrar las 20 primeras filas de este conjunto? 1\u00aa Pista Tienes que utilizar print() . Puedes averiguar c\u00f3mo usarlo escribiendo el comando ?print en la consola. 2\u00aa Pista Utiliza el argumento n = <N\u00daMERO> dentro del comando anterior. Respuesta Empleamos el siguiente comando: 1 > print ( mpg , n = 20 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class <chr> <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2 2008 4 auto(av) f 21 30 p compact 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact 11 audi a4 quattro 2 2008 4 auto(s6) 4 19 27 p compact 12 audi a4 quattro 2.8 1999 6 auto(l5) 4 15 25 p compact 13 audi a4 quattro 2.8 1999 6 manual(m5) 4 17 25 p compact 14 audi a4 quattro 3.1 2008 6 auto(s6) 4 17 25 p compact 15 audi a4 quattro 3.1 2008 6 manual(m6) 4 15 25 p compact 16 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize 17 audi a6 quattro 3.1 2008 6 auto(s6) 4 17 25 p midsize 18 audi a6 quattro 4.2 2008 8 auto(s6) 4 16 23 p midsize 19 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 20 r suv 20 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 15 e suv # ... with 214 more rows Nota Puedes encontrar informaci\u00f3n sobre cualquier comando o paquete usando ?<NOMBRE_COMANDO> o ?<NOMBRE_PAQUETE> . Este abrir\u00e1 una \" vignette \", es decir, una gu\u00eda con toda la informaci\u00f3n necesaria, que aparece en la pesta\u00f1a \" Help \" (ventana de la esquina inferior derecha en RStudio ). Puedes saber m\u00e1s acerca de las \" vignettes \" aqu\u00ed . mpg es un conjunto de datos que re\u00fane informaci\u00f3n sobre el consumo de combustible de diferentes veh\u00edculos, cuyas variables son las siguientes: VARIABLE DESCRIPCI\u00d3N manufacturer Nombre de la empresa fabricante model Modelo espec\u00edfico del veh\u00edculo displ Cilindrada (en litros) year A\u00f1o de fabricaci\u00f3n cyl N\u00famero de cilindros trans Tipo de transmisi\u00f3n (manual o autom\u00e1tica) drv Tipo de tren de transmisi\u00f3n (frontal, trasera o 4x4) cty Gasto en ciudad (millas por gal\u00f3n) hwy Gasto en carretera (millas por gal\u00f3n) fl Tipo de combustible class Tipo de coche Conociendo qu\u00e9 significa cada variable, podemos empezar a representarlas gr\u00e1ficamente de forma l\u00f3gica. El esquema que vamos a seguir para ello es el siguiente: 1 2 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) Empezamos con la funci\u00f3n ggplot() , que crea el sistema de coordenadas en el que se representan los datos. Dentro de esta funci\u00f3n debemos incluir el conjunto de datos al que pertenecen las variables que queremos representar (en este caso, data = mpg ): Importante: En ggplot2 , para continuar con el comando en la siguiente l\u00ednea, es necesario colocar un s\u00edmbolo \"+\" al final de la anterior. Como todav\u00eda no hemos elegido las variables, la gr\u00e1fica permanece en blanco. Para seleccionarlas, primero debemos elegir el tipo de gr\u00e1fico que queremos crear, siendo este dependiente del tipo de variable (si son continuas o discontinuas) que vamos a representar. Los diferentes tipos de gr\u00e1ficos los iremos viendo conforme avanzamos en el tutorial. Algunos de estos son: TIPO DE GR\u00c1FICA DESCRIPCI\u00d3N geom_point Diagrama de dispersi\u00f3n geom_smooth Gr\u00e1fico de l\u00ednea suavizada geom_bar Diagrama de barras (proporcional) geom_col Diagrama de barras (valores totales) geom_boxplot Diagrama de cajas Por ahora, vamos a utilizar geom_point , que genera un diagrama de dispersi\u00f3n. Finalmente, tenemos que elegir las variables que vamos a mostrar. Para ello, debemos emplear la funci\u00f3n mapping , que define las variables a representar. Esta debe ir acompa\u00f1ada del argumento aes() , junto con las variables x e y (en nuestro caso, x = displ e y = hwy ). Veamos c\u00f3mo quedar\u00eda este ejemplo. 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) Obtenemos una gr\u00e1fica como esta: Razona: Prueba a hacer lo mismo, pero representando el gasto en carretera vs. el gasto en ciudad. \u00bfQu\u00e9 observas? Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = hwy , y = cty )) La relaci\u00f3n entre el gasto de combustible en carretera y en ciudad sigue una clara tendencia lineal. Aesthetics El comando aes() , adem\u00e1s de para introducir las variables principales (x e y), sirve para introducir otras variables y modificar de qu\u00e9 forma se van a ver en la gr\u00e1fica . Ilustr\u00e1ndonos con el ejemplo anterior, podemos ver c\u00f3mo la gr\u00e1fica nos muestra la relaci\u00f3n que existe entre el consumo de un determinado veh\u00edculo y su cilindrada. Si quisi\u00e9ramos observar la relaci\u00f3n que tienen estos resultados con la variable class (el tipo de coche), podemos introducirla dentro del comando aes() como propiedad visual. Representamos la clase de coche dentro de la gr\u00e1fica anterior cambiando el color de los puntos empleando el argumento color : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) Como vemos, adem\u00e1s de representar el gasto en carretera con respecto a la cilindrada, vemos con cada color cada tipo de coche que hay, revelando informaci\u00f3n extra. Razona: Observando el ejemplo anterior, \u00bfa qu\u00e9 conclusi\u00f3n puedes llegar en relaci\u00f3n al tipo de veh\u00edculo, su gasto en carretera y su cilindrada? Respuesta: Los coches, por norma general, gastan m\u00e1s en carretera conforme aumenta su cilindrada. Sin embargo, en este ejemplo existe un grupo de coches que no sigue esta suposici\u00f3n. Al observar la variable que determina el tipo de coche en la gr\u00e1fica, vemos como estos veh\u00edculos son de dos asientos, que, al pesar menos, gastan menos combustible que los dem\u00e1s, independientemente del tama\u00f1o del motor. Podemos mapear cualquier variable dentro del gr\u00e1fico incluy\u00e9ndola en aes() . Adem\u00e1s, podemos elegir que propiedad visual asignar a esta (color, tama\u00f1o de los puntos...). Podemos representar el tipo de veh\u00edculos cambiando el tama\u00f1o de los puntos (con size ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , size = class )) Tambi\u00e9n podemos cambiar su transparencia (con alpha ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , alpha = class )) E incluso la forma de los puntos (con shape ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , shape = class )) Estos ejemplos, sin embargo, muestran una serie de problemas. En los dos primeros se dificulta la visi\u00f3n de algunos puntos, mientras que en el tercero ggplot2 \u00fanicamente representa seis formas de puntos, que son f\u00e1cilmente diferenciables entre s\u00ed. Cuando el n\u00famero de valores es mayor a seis, se dejan de representar algunas de estos. Estos aesthetics , por tanto, solo se emplean en casos muy espec\u00edficos. Nota Puedes dise\u00f1ar otras gr\u00e1ficas empleando diferentes aesthetics . Prueba a mirar todos los aesthetics posibles para el diagrama de dispersi\u00f3n usando ?geom_point . Una cosa muy importante para tener en cuenta es que aes() solo sirve para modificar las gr\u00e1ficas con respecto a una variable. Tambi\u00e9n podemos modificarla sin tener en cuenta los valores. Por ejemplo, podemos cambiar el color de todos los puntos sacando color del comando aes() : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy ), color = \"blue\" ) Si introduj\u00e9semos color = \"blue\" dentro de aes() se muestra una gr\u00e1fica sin sentido, pues ggplot2 interpreta que no existe ninguna variable llamada blue : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = \"blue\" )) Dise\u00f1a un diagrama de dispersi\u00f3n que represente la cilindrada vs. el gasto en ciudad Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty )) Sobre la gr\u00e1fica del ejercicio anterior, cambia la forma de los puntos por cuadrados ( shape = 15 ) y representa el tipo de combustible seg\u00fan el color. Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = fl ), shape = 15 ) En el ejemplo anterior, \u00bfc\u00f3mo modificar\u00edas la gr\u00e1fica de forma que represente aquellos veh\u00edculos con una cilindrada menor que 5 de un color y aquellos con cilindrada mayor de otro? Pista: Trata de usar color = displ < 5 . Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = displ < 5 )) Gr\u00e1ficos estad\u00edsticos Son gr\u00e1ficos estad\u00edsticos aquellos que representan datos cuantitativos. Entre ellos encontramos los gr\u00e1ficos de dispersi\u00f3n (repasados en el apartado anterior), diagramas de barras, diagramas de cajas, histogramas, etc. Para estudiar estos gr\u00e1ficos vamos a usar un nuevo conjunto de datos denominado \" diamonds \", incluido en ggplot2 , que contiene informaci\u00f3n sobre diferentes propiedades de un gran n\u00famero de diamantes. Nota Puedes encontrar toda la informaci\u00f3n sobre este dataset (variables, descripciones, etc.) empleando el comando ?diamonds . Empecemos estudiando los gr\u00e1ficos de barras empleando el comando geom_bar() , de la misma forma que con los gr\u00e1ficos de dispersi\u00f3n. Imaginemos que queremos clasificar los diamantes seg\u00fan la calidad del corte (variable cut ). Para ello, usamos: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut )) ggplot2 interpreta autom\u00e1ticamente que, al no concretar la variable y , debe representar el n\u00famero total de diamantes por calidad de corte. Para ello, ggplot2 emplea unas transformaciones estad\u00edsticas capaces de crear nuevas variables modificando las ya existentes. En este caso, lo que hace es contar el n\u00famero de diamantes dentro de cada tipo de corte. Nota Si quieres saber m\u00e1s sobre estas transformaciones estad\u00edsticas, puedes encontrar m\u00e1s informaci\u00f3n aqu\u00ed . Al igual que el resto de gr\u00e1ficas, empleando aes() puedes modificar la apariencia del gr\u00e1fico de barras. En los gr\u00e1ficos de barras, color cambia el color del borde de las barras y fill cambia el color del relleno. Por ejemplo, podemos representar la claridad de los diamantes (variable clarity ) de la siguiente forma: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut , fill = clarity )) Tambi\u00e9n podemos representar diagramas de cajas , empleando la funci\u00f3n geom_box . Como ejemplo, podemos representar el gasto en carretera seg\u00fan el tipo de coche de la siguiente manera: 1 2 ggplot ( data = mpg ) + geom_boxplot ( mapping = aes ( x = class , y = hwy )) Si necesitamos girar la gr\u00e1fica, simplemente a\u00f1adimos coord_flip() justo a continuaci\u00f3n: 1 2 3 ggplot ( data = mpg ) + geom_boxplot ( mapping = aes ( x = class , y = hwy )) + coord_flip () Gr\u00e1ficas m\u00faltiples A veces, para facilitar la visualizaci\u00f3n de los datos, es necesario representar varias gr\u00e1ficas a la vez. Para ello, existen dos formas: Representar muchas variables dentro de una misma gr\u00e1fica ( por capas ). Dividir los datos en varias ventanas ( facets ). Gr\u00e1ficas por capas ggplot2 permite representar muchas variables en una misma gr\u00e1fica de forma sencilla. Supongamos que necesitamos representar una l\u00ednea de tendencia del gasto en carretera con respecto a la cilindrada. Usando geom_smooth() dibujamos una l\u00ednea de tendencia suavizada del conjunto de datos propuesto: 1 2 ggplot ( data = mpg ) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Nota Al igual que con el resto de funciones geom , geom_smooth() tambi\u00e9n posee sus aesthetics espec\u00edficos (tipo, grosor, color de l\u00ednea...). Puedes usar ?geom_smooth para ver los que hay disponibles. Si quisi\u00e9ramos representar esta l\u00ednea como una capa sobre un diagrama de dispersi\u00f3n, simplemente escribimos sus respectivas funciones geom una despu\u00e9s de la otra: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Podemos combinar tantas capas como queramos, siempre y cuando no existan incoherencias entre las variables representadas. Gr\u00e1ficas por ventanas ( facets ) Supongamos que queremos representar el gasto en carretera con respecto a la cilindrada. Imaginemos tambi\u00e9n que queremos representar los tipos de veh\u00edculos. Podemos hacer como hicimos antes, es decir, representar los tipos de veh\u00edculos seg\u00fan el color. Esto, sin embargo, a veces puede resultar en gr\u00e1ficas dif\u00edciles de observar, pues es complicado distinguir los diferentes valores. Para solucionar esto podemos usar los facets , con los que es posible representar muchas gr\u00e1ficas a la vez dividiendo las variables en numerosos paneles . Para ello, usamos facet_wrap() . Se usa de la siguiente forma: 1 2 3 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) + facet_wrap ( ~ < VARIABLE > , nrow = < N\u00daMERO DE FILAS > ) Representamos el ejemplo anterior: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_wrap ( ~ class , nrow = 2 ) Con facets podemos representar dos variables , empleando la funci\u00f3n facet_grid() . Por ejemplo, usemos como variables el tipo de tren de transmisi\u00f3n y el n\u00famero de cilindros: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_grid ( drv ~ cyl ) Los facets son muy \u00fatiles cuando queremos tener una visi\u00f3n global de todas las posibles representaciones que podemos hacer para luego seleccionar la que m\u00e1s nos interese. Con el material visto hasta ahora, estamos bastante preparados para representar datos ordenados de forma l\u00f3gica y agradable. Existen much\u00edsimas m\u00e1s opciones para graficar empleando ggplot2 , aunque en este tutorial \u00fanicamente hemos mostrado lo que nos parece esencial. Si quieres saber m\u00e1s, puedes revisar el resto de posibilidades aqu\u00ed ). Ejercicios Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"visualizar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja R for Data Science ; Hadley Wickham, Garrett Grolemund et al. R packages - Vignettes: long-form documentation ; Hadley Wickham, Jenny Bryan","title":"Visualizar datos"},{"location":"visualizar/#visualizacion-de-datos","text":"","title":"Visualizaci\u00f3n de datos"},{"location":"visualizar/#introduccion","text":"Es innegable que la ciencia de datos, sobre todo para los reci\u00e9n llegados, puede resultar un poco \"dif\u00edcil y aburrida\". Podemos deducir del esquema del apartado anterior que, a la hora de entrar en la ciencia de datos, lo mejor es empezar por el principio, es decir, importar, ordenar y transformar los datos. Sin embargo, esta tarea puede ser un poco frustrante. Tidyverse , por tanto, propone comenzar el estudio de esta disciplina por la parte de visualizaci\u00f3n de datos que ya han sido ordenados y transformados, tarea mucho m\u00e1s amigable para los principiantes. El paquete de Tidyverse encargado de la generaci\u00f3n de gr\u00e1ficas es ggplot2 . Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse ) En la consola veremos el siguiente mensaje: 1 2 3 4 5 6 7 8 #> \u2500\u2500 Attaching packages \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse 1.3.0 \u2500\u2500 #> \u2714 ggplot2 3.3.2 \u2714 purrr 0.3.4 #> \u2714 tibble 3.0.3 \u2714 dplyr 1.0.2 #> \u2714 tidyr 1.1.2 \u2714 stringr 1.4.0 #> \u2714 readr 1.4.0 \u2714 forcats 0.5.0 #> \u2500\u2500 Conflicts \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse_conflicts() \u2500\u2500 #> \u2716 dplyr::filter() masks stats::filter() #> \u2716 dplyr::lag() masks stats::lag() Nota Activaremos Tidyverse cada vez que iniciemos una nueva sesi\u00f3n en RStudio. Podemos ver, adem\u00e1s, como hay algunos paquetes en conflicto con otras funciones de R base, pero eso no importa demasiado. ggplot2 , junto con el resto de paquetes de Tidyverse , est\u00e1 activo y listo para graficar con \u00e9l. Como todav\u00eda no sabemos importar nuestros propios datos a Tidyverse , vamos a usar una serie de conjuntos de datos incluidos de serie en este paquete, con los que podemos practicar. Podemos ver uno de ellos con el comando mpg : 1 mpg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class < chr > < chr > < dbl > < int > < int > < chr > < chr > < int > < int > < chr > < chr > 1 audi a4 1.8 1999 4 auto ( l5 ) f 18 29 p compact 2 audi a4 1.8 1999 4 manual ( m5 ) f 21 29 p compact 3 audi a4 2 2008 4 manual ( m6 ) f 20 31 p compact 4 audi a4 2 2008 4 auto ( av ) f 21 30 p compact 5 audi a4 2.8 1999 6 auto ( l5 ) f 16 26 p compact 6 audi a4 2.8 1999 6 manual ( m5 ) f 18 26 p compact 7 audi a4 3.1 2008 6 auto ( av ) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual ( m5 ) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto ( l5 ) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual ( m6 ) 4 20 28 p compact # ... with 224 more rows Razona: \u00bfC\u00f3mo podr\u00edas mostrar las 20 primeras filas de este conjunto? 1\u00aa Pista Tienes que utilizar print() . Puedes averiguar c\u00f3mo usarlo escribiendo el comando ?print en la consola. 2\u00aa Pista Utiliza el argumento n = <N\u00daMERO> dentro del comando anterior. Respuesta Empleamos el siguiente comando: 1 > print ( mpg , n = 20 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class <chr> <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2 2008 4 auto(av) f 21 30 p compact 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact 11 audi a4 quattro 2 2008 4 auto(s6) 4 19 27 p compact 12 audi a4 quattro 2.8 1999 6 auto(l5) 4 15 25 p compact 13 audi a4 quattro 2.8 1999 6 manual(m5) 4 17 25 p compact 14 audi a4 quattro 3.1 2008 6 auto(s6) 4 17 25 p compact 15 audi a4 quattro 3.1 2008 6 manual(m6) 4 15 25 p compact 16 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize 17 audi a6 quattro 3.1 2008 6 auto(s6) 4 17 25 p midsize 18 audi a6 quattro 4.2 2008 8 auto(s6) 4 16 23 p midsize 19 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 20 r suv 20 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 15 e suv # ... with 214 more rows Nota Puedes encontrar informaci\u00f3n sobre cualquier comando o paquete usando ?<NOMBRE_COMANDO> o ?<NOMBRE_PAQUETE> . Este abrir\u00e1 una \" vignette \", es decir, una gu\u00eda con toda la informaci\u00f3n necesaria, que aparece en la pesta\u00f1a \" Help \" (ventana de la esquina inferior derecha en RStudio ). Puedes saber m\u00e1s acerca de las \" vignettes \" aqu\u00ed . mpg es un conjunto de datos que re\u00fane informaci\u00f3n sobre el consumo de combustible de diferentes veh\u00edculos, cuyas variables son las siguientes: VARIABLE DESCRIPCI\u00d3N manufacturer Nombre de la empresa fabricante model Modelo espec\u00edfico del veh\u00edculo displ Cilindrada (en litros) year A\u00f1o de fabricaci\u00f3n cyl N\u00famero de cilindros trans Tipo de transmisi\u00f3n (manual o autom\u00e1tica) drv Tipo de tren de transmisi\u00f3n (frontal, trasera o 4x4) cty Gasto en ciudad (millas por gal\u00f3n) hwy Gasto en carretera (millas por gal\u00f3n) fl Tipo de combustible class Tipo de coche Conociendo qu\u00e9 significa cada variable, podemos empezar a representarlas gr\u00e1ficamente de forma l\u00f3gica. El esquema que vamos a seguir para ello es el siguiente: 1 2 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) Empezamos con la funci\u00f3n ggplot() , que crea el sistema de coordenadas en el que se representan los datos. Dentro de esta funci\u00f3n debemos incluir el conjunto de datos al que pertenecen las variables que queremos representar (en este caso, data = mpg ): Importante: En ggplot2 , para continuar con el comando en la siguiente l\u00ednea, es necesario colocar un s\u00edmbolo \"+\" al final de la anterior. Como todav\u00eda no hemos elegido las variables, la gr\u00e1fica permanece en blanco. Para seleccionarlas, primero debemos elegir el tipo de gr\u00e1fico que queremos crear, siendo este dependiente del tipo de variable (si son continuas o discontinuas) que vamos a representar. Los diferentes tipos de gr\u00e1ficos los iremos viendo conforme avanzamos en el tutorial. Algunos de estos son: TIPO DE GR\u00c1FICA DESCRIPCI\u00d3N geom_point Diagrama de dispersi\u00f3n geom_smooth Gr\u00e1fico de l\u00ednea suavizada geom_bar Diagrama de barras (proporcional) geom_col Diagrama de barras (valores totales) geom_boxplot Diagrama de cajas Por ahora, vamos a utilizar geom_point , que genera un diagrama de dispersi\u00f3n. Finalmente, tenemos que elegir las variables que vamos a mostrar. Para ello, debemos emplear la funci\u00f3n mapping , que define las variables a representar. Esta debe ir acompa\u00f1ada del argumento aes() , junto con las variables x e y (en nuestro caso, x = displ e y = hwy ). Veamos c\u00f3mo quedar\u00eda este ejemplo. 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) Obtenemos una gr\u00e1fica como esta: Razona: Prueba a hacer lo mismo, pero representando el gasto en carretera vs. el gasto en ciudad. \u00bfQu\u00e9 observas? Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = hwy , y = cty )) La relaci\u00f3n entre el gasto de combustible en carretera y en ciudad sigue una clara tendencia lineal.","title":"Introducci\u00f3n"},{"location":"visualizar/#aesthetics","text":"El comando aes() , adem\u00e1s de para introducir las variables principales (x e y), sirve para introducir otras variables y modificar de qu\u00e9 forma se van a ver en la gr\u00e1fica . Ilustr\u00e1ndonos con el ejemplo anterior, podemos ver c\u00f3mo la gr\u00e1fica nos muestra la relaci\u00f3n que existe entre el consumo de un determinado veh\u00edculo y su cilindrada. Si quisi\u00e9ramos observar la relaci\u00f3n que tienen estos resultados con la variable class (el tipo de coche), podemos introducirla dentro del comando aes() como propiedad visual. Representamos la clase de coche dentro de la gr\u00e1fica anterior cambiando el color de los puntos empleando el argumento color : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) Como vemos, adem\u00e1s de representar el gasto en carretera con respecto a la cilindrada, vemos con cada color cada tipo de coche que hay, revelando informaci\u00f3n extra. Razona: Observando el ejemplo anterior, \u00bfa qu\u00e9 conclusi\u00f3n puedes llegar en relaci\u00f3n al tipo de veh\u00edculo, su gasto en carretera y su cilindrada? Respuesta: Los coches, por norma general, gastan m\u00e1s en carretera conforme aumenta su cilindrada. Sin embargo, en este ejemplo existe un grupo de coches que no sigue esta suposici\u00f3n. Al observar la variable que determina el tipo de coche en la gr\u00e1fica, vemos como estos veh\u00edculos son de dos asientos, que, al pesar menos, gastan menos combustible que los dem\u00e1s, independientemente del tama\u00f1o del motor. Podemos mapear cualquier variable dentro del gr\u00e1fico incluy\u00e9ndola en aes() . Adem\u00e1s, podemos elegir que propiedad visual asignar a esta (color, tama\u00f1o de los puntos...). Podemos representar el tipo de veh\u00edculos cambiando el tama\u00f1o de los puntos (con size ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , size = class )) Tambi\u00e9n podemos cambiar su transparencia (con alpha ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , alpha = class )) E incluso la forma de los puntos (con shape ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , shape = class )) Estos ejemplos, sin embargo, muestran una serie de problemas. En los dos primeros se dificulta la visi\u00f3n de algunos puntos, mientras que en el tercero ggplot2 \u00fanicamente representa seis formas de puntos, que son f\u00e1cilmente diferenciables entre s\u00ed. Cuando el n\u00famero de valores es mayor a seis, se dejan de representar algunas de estos. Estos aesthetics , por tanto, solo se emplean en casos muy espec\u00edficos. Nota Puedes dise\u00f1ar otras gr\u00e1ficas empleando diferentes aesthetics . Prueba a mirar todos los aesthetics posibles para el diagrama de dispersi\u00f3n usando ?geom_point . Una cosa muy importante para tener en cuenta es que aes() solo sirve para modificar las gr\u00e1ficas con respecto a una variable. Tambi\u00e9n podemos modificarla sin tener en cuenta los valores. Por ejemplo, podemos cambiar el color de todos los puntos sacando color del comando aes() : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy ), color = \"blue\" ) Si introduj\u00e9semos color = \"blue\" dentro de aes() se muestra una gr\u00e1fica sin sentido, pues ggplot2 interpreta que no existe ninguna variable llamada blue : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = \"blue\" )) Dise\u00f1a un diagrama de dispersi\u00f3n que represente la cilindrada vs. el gasto en ciudad Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty )) Sobre la gr\u00e1fica del ejercicio anterior, cambia la forma de los puntos por cuadrados ( shape = 15 ) y representa el tipo de combustible seg\u00fan el color. Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = fl ), shape = 15 ) En el ejemplo anterior, \u00bfc\u00f3mo modificar\u00edas la gr\u00e1fica de forma que represente aquellos veh\u00edculos con una cilindrada menor que 5 de un color y aquellos con cilindrada mayor de otro? Pista: Trata de usar color = displ < 5 . Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = displ < 5 ))","title":"Aesthetics"},{"location":"visualizar/#graficos-estadisticos","text":"Son gr\u00e1ficos estad\u00edsticos aquellos que representan datos cuantitativos. Entre ellos encontramos los gr\u00e1ficos de dispersi\u00f3n (repasados en el apartado anterior), diagramas de barras, diagramas de cajas, histogramas, etc. Para estudiar estos gr\u00e1ficos vamos a usar un nuevo conjunto de datos denominado \" diamonds \", incluido en ggplot2 , que contiene informaci\u00f3n sobre diferentes propiedades de un gran n\u00famero de diamantes. Nota Puedes encontrar toda la informaci\u00f3n sobre este dataset (variables, descripciones, etc.) empleando el comando ?diamonds . Empecemos estudiando los gr\u00e1ficos de barras empleando el comando geom_bar() , de la misma forma que con los gr\u00e1ficos de dispersi\u00f3n. Imaginemos que queremos clasificar los diamantes seg\u00fan la calidad del corte (variable cut ). Para ello, usamos: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut )) ggplot2 interpreta autom\u00e1ticamente que, al no concretar la variable y , debe representar el n\u00famero total de diamantes por calidad de corte. Para ello, ggplot2 emplea unas transformaciones estad\u00edsticas capaces de crear nuevas variables modificando las ya existentes. En este caso, lo que hace es contar el n\u00famero de diamantes dentro de cada tipo de corte. Nota Si quieres saber m\u00e1s sobre estas transformaciones estad\u00edsticas, puedes encontrar m\u00e1s informaci\u00f3n aqu\u00ed . Al igual que el resto de gr\u00e1ficas, empleando aes() puedes modificar la apariencia del gr\u00e1fico de barras. En los gr\u00e1ficos de barras, color cambia el color del borde de las barras y fill cambia el color del relleno. Por ejemplo, podemos representar la claridad de los diamantes (variable clarity ) de la siguiente forma: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut , fill = clarity )) Tambi\u00e9n podemos representar diagramas de cajas , empleando la funci\u00f3n geom_box . Como ejemplo, podemos representar el gasto en carretera seg\u00fan el tipo de coche de la siguiente manera: 1 2 ggplot ( data = mpg ) + geom_boxplot ( mapping = aes ( x = class , y = hwy )) Si necesitamos girar la gr\u00e1fica, simplemente a\u00f1adimos coord_flip() justo a continuaci\u00f3n: 1 2 3 ggplot ( data = mpg ) + geom_boxplot ( mapping = aes ( x = class , y = hwy )) + coord_flip ()","title":"Gr\u00e1ficos estad\u00edsticos"},{"location":"visualizar/#graficas-multiples","text":"A veces, para facilitar la visualizaci\u00f3n de los datos, es necesario representar varias gr\u00e1ficas a la vez. Para ello, existen dos formas: Representar muchas variables dentro de una misma gr\u00e1fica ( por capas ). Dividir los datos en varias ventanas ( facets ).","title":"Gr\u00e1ficas m\u00faltiples"},{"location":"visualizar/#graficas-por-capas","text":"ggplot2 permite representar muchas variables en una misma gr\u00e1fica de forma sencilla. Supongamos que necesitamos representar una l\u00ednea de tendencia del gasto en carretera con respecto a la cilindrada. Usando geom_smooth() dibujamos una l\u00ednea de tendencia suavizada del conjunto de datos propuesto: 1 2 ggplot ( data = mpg ) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Nota Al igual que con el resto de funciones geom , geom_smooth() tambi\u00e9n posee sus aesthetics espec\u00edficos (tipo, grosor, color de l\u00ednea...). Puedes usar ?geom_smooth para ver los que hay disponibles. Si quisi\u00e9ramos representar esta l\u00ednea como una capa sobre un diagrama de dispersi\u00f3n, simplemente escribimos sus respectivas funciones geom una despu\u00e9s de la otra: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Podemos combinar tantas capas como queramos, siempre y cuando no existan incoherencias entre las variables representadas.","title":"Gr\u00e1ficas por capas"},{"location":"visualizar/#graficas-por-ventanas-facets","text":"Supongamos que queremos representar el gasto en carretera con respecto a la cilindrada. Imaginemos tambi\u00e9n que queremos representar los tipos de veh\u00edculos. Podemos hacer como hicimos antes, es decir, representar los tipos de veh\u00edculos seg\u00fan el color. Esto, sin embargo, a veces puede resultar en gr\u00e1ficas dif\u00edciles de observar, pues es complicado distinguir los diferentes valores. Para solucionar esto podemos usar los facets , con los que es posible representar muchas gr\u00e1ficas a la vez dividiendo las variables en numerosos paneles . Para ello, usamos facet_wrap() . Se usa de la siguiente forma: 1 2 3 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) + facet_wrap ( ~ < VARIABLE > , nrow = < N\u00daMERO DE FILAS > ) Representamos el ejemplo anterior: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_wrap ( ~ class , nrow = 2 ) Con facets podemos representar dos variables , empleando la funci\u00f3n facet_grid() . Por ejemplo, usemos como variables el tipo de tren de transmisi\u00f3n y el n\u00famero de cilindros: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_grid ( drv ~ cyl ) Los facets son muy \u00fatiles cuando queremos tener una visi\u00f3n global de todas las posibles representaciones que podemos hacer para luego seleccionar la que m\u00e1s nos interese. Con el material visto hasta ahora, estamos bastante preparados para representar datos ordenados de forma l\u00f3gica y agradable. Existen much\u00edsimas m\u00e1s opciones para graficar empleando ggplot2 , aunque en este tutorial \u00fanicamente hemos mostrado lo que nos parece esencial. Si quieres saber m\u00e1s, puedes revisar el resto de posibilidades aqu\u00ed ).","title":"Gr\u00e1ficas por ventanas (facets)"},{"location":"visualizar/#ejercicios","text":"Ejercicios de repaso Para ver si has entendido todo, intenta realizar estos ejercicios propuestos . Para saber c\u00f3mo hacerlos, visita el apartado de \"Realizaci\u00f3n de ejercicios\" . Tras esto, ejecuta el siguiente comando: 1 learnr :: run_tutorial ( \"visualizar\" , \"tutoradvr\" ) Se abrir\u00e1 una ventana en tu navegador con los ejercicios a resolver. Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja R for Data Science ; Hadley Wickham, Garrett Grolemund et al. R packages - Vignettes: long-form documentation ; Hadley Wickham, Jenny Bryan","title":"Ejercicios"},{"location":"datos/","text":"Escribe fuente de datos","title":"Index"}]}