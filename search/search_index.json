{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contexto docente Este tutorial sirve como complemento para el aprendizaje de la materia \"Inform\u00e1tica Aplicada a la Bioqu\u00edmica\" , impartida en el grado de Bioqu\u00edmica en la Universidad de C\u00f3rdoba, y se considera una continuaci\u00f3n del tutorial realizado por Ismael S\u00e1nchez Pareja, en el cual se detallan los aspectos m\u00e1s b\u00e1sicos para la programaci\u00f3n en R y, por tanto, muchos conocimientos estudiados en \u00e9l se dan por aprendidos en este (puedes verlo haciendo click aqu\u00ed ). Uso de R en el \u00e1mbito de la bioqu\u00edmica R es un entorno y lenguaje de programaci\u00f3n enfocado en el an\u00e1lisis estad\u00edstico, preparado para la observaci\u00f3n, manipulaci\u00f3n y representaci\u00f3n de datos, siendo capaz de adaptar una gran cantidad de t\u00e9cnicas estad\u00edsticas y gr\u00e1ficas. Adem\u00e1s, es altamente modificable empleando multitud de software y librer\u00edas de funciones. El lenguaje R, en definitiva, es muy amplio, e intentar abarcarlo todo es una tarea compleja. Lo que hemos estudiado hasta ahora en R son los aspectos b\u00e1sicos de este lenguaje, y c\u00f3mo podemos manejarnos con \u00e9l sin demasiada dificultad. Pero, \u00bfsabemos aplicar lo que conocemos directamente en el desarrollo de nuestros estudios?. Lo cierto es que esto es un poco m\u00e1s complicado. Es verdad que, por ahora, somos capaces de dise\u00f1ar nuestros propios estudios anal\u00edticos a nivel \"casero\", es decir, estudios simples con una cantidad de datos f\u00e1cilmente manejables (como pueden ser los obtenidos en una pr\u00e1ctica de laboratorio). Sin embargo, cuamdo nos encontremos en el \u00e1mbito laboral o el de investigaci\u00f3n, nos vamos a encontrar con cantidades de datos enormes, imposibles de asimilar empleando \u00fanicamente nuestra mente. Es entonces cuando entra en juego la imprescindible ciencia de datos . Pues bien, el objetivo de este tutorial, junto con el anterior, es ense\u00f1ar a los estudiantes del grado de biqu\u00edmica interesados a aplicar todos los conocimientos adquiridos en simulaciones de situaciones reales, con la finalidad de adquirir la capacidad de aplicarlos en sus propios estudios. Referencias Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja","title":"Inicio"},{"location":"#contexto-docente","text":"Este tutorial sirve como complemento para el aprendizaje de la materia \"Inform\u00e1tica Aplicada a la Bioqu\u00edmica\" , impartida en el grado de Bioqu\u00edmica en la Universidad de C\u00f3rdoba, y se considera una continuaci\u00f3n del tutorial realizado por Ismael S\u00e1nchez Pareja, en el cual se detallan los aspectos m\u00e1s b\u00e1sicos para la programaci\u00f3n en R y, por tanto, muchos conocimientos estudiados en \u00e9l se dan por aprendidos en este (puedes verlo haciendo click aqu\u00ed ).","title":"Contexto docente"},{"location":"#uso-de-r-en-el-ambito-de-la-bioquimica","text":"R es un entorno y lenguaje de programaci\u00f3n enfocado en el an\u00e1lisis estad\u00edstico, preparado para la observaci\u00f3n, manipulaci\u00f3n y representaci\u00f3n de datos, siendo capaz de adaptar una gran cantidad de t\u00e9cnicas estad\u00edsticas y gr\u00e1ficas. Adem\u00e1s, es altamente modificable empleando multitud de software y librer\u00edas de funciones. El lenguaje R, en definitiva, es muy amplio, e intentar abarcarlo todo es una tarea compleja. Lo que hemos estudiado hasta ahora en R son los aspectos b\u00e1sicos de este lenguaje, y c\u00f3mo podemos manejarnos con \u00e9l sin demasiada dificultad. Pero, \u00bfsabemos aplicar lo que conocemos directamente en el desarrollo de nuestros estudios?. Lo cierto es que esto es un poco m\u00e1s complicado. Es verdad que, por ahora, somos capaces de dise\u00f1ar nuestros propios estudios anal\u00edticos a nivel \"casero\", es decir, estudios simples con una cantidad de datos f\u00e1cilmente manejables (como pueden ser los obtenidos en una pr\u00e1ctica de laboratorio). Sin embargo, cuamdo nos encontremos en el \u00e1mbito laboral o el de investigaci\u00f3n, nos vamos a encontrar con cantidades de datos enormes, imposibles de asimilar empleando \u00fanicamente nuestra mente. Es entonces cuando entra en juego la imprescindible ciencia de datos . Pues bien, el objetivo de este tutorial, junto con el anterior, es ense\u00f1ar a los estudiantes del grado de biqu\u00edmica interesados a aplicar todos los conocimientos adquiridos en simulaciones de situaciones reales, con la finalidad de adquirir la capacidad de aplicarlos en sus propios estudios.","title":"Uso de R en el \u00e1mbito de la bioqu\u00edmica"},{"location":"#referencias","text":"Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja","title":"Referencias"},{"location":"ejercicios/","text":"\u00bfC\u00f3mo hacer los ejercicios de repaso? Referencias Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja","title":"Realizaci\u00f3n de ejercicios"},{"location":"ejercicios/#como-hacer-los-ejercicios-de-repaso","text":"","title":"\u00bfC\u00f3mo hacer los ejercicios de repaso?"},{"location":"ejercicios/#referencias","text":"Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja","title":"Referencias"},{"location":"genesis/","text":"Introducci\u00f3n Referencias Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja GENESIS ; Bioconductor","title":"GENESIS"},{"location":"genesis/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"genesis/#referencias","text":"Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja GENESIS ; Bioconductor","title":"Referencias"},{"location":"importar/","text":"Introducci\u00f3n Con el material visto hasta ahora, estamos bastante preparados para representar datos ordenados de forma l\u00f3gica y agradable. Existen much\u00edsimas m\u00e1s opciones para graficar empleando ggplot2 , aunque en este tutorial \u00fanicamente hemos mostrado lo que nos parece esencial (para saber m\u00e1s, puedes revisar el resto de posibilidades aqu\u00ed ). Sin embargo, aunque ya sepamos mucho sobre graficaci\u00f3n, todav\u00eda no hemos ense\u00f1ado c\u00f3mo importar nuestros propios datos y emplear todo lo estudiado en nuestros propios trabajos, tema que vamos a ver a continuaci\u00f3n. Vamos a emplear el paquete de Tidyverse readr , que es el que se encarga de importar los datos. Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse ) Tibbles El c\u00f3digo base de R utiliza data.frame a la hora de representar datos en tablas. Sin embargo, estos son un poco antiguos y a veces se hace un poco engorroso trabajar con ellos. Tidyverse trata de solucionar esto empleando el paquete tibble . Los tibbles funcionan muy parecido a los data.frame , pero presentan caracter\u00edsticas que los hace mucho m\u00e1s sencillo trabajar con ellos: Son mucho m\u00e1s r\u00e1pidos . No transforman los vectores de caracteres a factores , cosa que s\u00ed ocurre con los data.frame . Son m\u00e1s reproducibles , es decir, es m\u00e1s probable que aquellos que trabajen con los mismos datos que t\u00fa lleguen a los mismos resultados. Podemos transformar cualquier data.frame en un tibble empleando as_tibble() . Empleemos esta funci\u00f3n con iris , un data.frame incluido en R: 1 as_tibble ( iris ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 150 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species <dbl> <dbl> <dbl> <dbl> <fct> 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 7 4.6 3.4 1.4 0.3 setosa 8 5 3.4 1.5 0.2 setosa 9 4.4 2.9 1.4 0.2 setosa 10 4.9 3.1 1.5 0.1 setosa # ... with 140 more rows Tambi\u00e9n puedes crear tus propios tibbles desde cero. Para ello, empleamos la funci\u00f3n tibble() , que construye las tablas por columnas. Por ejemplo: 1 2 3 4 5 tibble ( \"Columna 1\" = 1 : 5 , \"Columna 2\" = 2 , \"Columna 3\" = c ( 2 , 7 , 4 , 1 , 4 ), ) 1 2 3 4 5 6 7 8 # A tibble: 5 x 3 `Columna 1` `Columna 2` `Columna 3` <int> <dbl> <dbl> 1 1 2 2 2 2 2 7 3 3 2 4 4 4 2 1 5 5 2 4 Los tibbles ofrecen muchas posibilidades a la hora de crear tablas de datos. Si quieres saber m\u00e1s, puedes usar el comando ?tibble , o puedes consultar el manual oficial de Tidyverse aqu\u00ed . Importando datos Importar archivos de datos es muy sencillo, simplemente usa una de las siguientes funciones, dependiendo del tipo de delimitador por el que est\u00e9n separados tus datos: FUNCI\u00d3N DELIMITADOR read_csv() Coma read_csv2() Punto y coma read_tsv() Tabulaciones read_table() Espacio Razona: Encuentra un comando con el que puedas leer archivos con cualquier delimitador. Pista: Puedes revistar todos los comandos disponibles con ?read_delim Respuesta 1 read_delim ( < DATOS > , < DELIMITADOR > ) A partir de ahora, salvo excepciones, vamos a utilizar datos no incluidos dentro del paquete Tidyverse , empleando alguna de las funciones anteriores. Ejercicio Adelantemos un poco de trabajo. Abre y descarga este conjunto de datos y, teniendo en cuenta sus delimitadores, imp\u00f3rtalo a R. Respuesta Antes de bajarlo podemos comprobar que el archivo emplea tabulaciones como delimitadores. Por tanto, tras descargarlo en nuestro working directory , lo importamos y le asignamos la variable datos : 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver como nuestros datos ahora aparecen en la ventana environment , listos para ser usados: Ejercicios de repaso Para ver si has entendido todo, intenta realizar los ejercicios propuestos en este enlace . Nota Cosulta el apartado \" Realizaci\u00f3n de ejercicios \" para saber como descargar, instalar y completar esta tarea. Referencias Referencias R for Data Science ; Hadley Wickham, Garrett Grolemund et al. Morphometric discrimination of two allozymically diagnosed sibling species ; Wayland, Matthew T. et al.","title":"Importar datos"},{"location":"importar/#introduccion","text":"Con el material visto hasta ahora, estamos bastante preparados para representar datos ordenados de forma l\u00f3gica y agradable. Existen much\u00edsimas m\u00e1s opciones para graficar empleando ggplot2 , aunque en este tutorial \u00fanicamente hemos mostrado lo que nos parece esencial (para saber m\u00e1s, puedes revisar el resto de posibilidades aqu\u00ed ). Sin embargo, aunque ya sepamos mucho sobre graficaci\u00f3n, todav\u00eda no hemos ense\u00f1ado c\u00f3mo importar nuestros propios datos y emplear todo lo estudiado en nuestros propios trabajos, tema que vamos a ver a continuaci\u00f3n. Vamos a emplear el paquete de Tidyverse readr , que es el que se encarga de importar los datos. Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse )","title":"Introducci\u00f3n"},{"location":"importar/#tibbles","text":"El c\u00f3digo base de R utiliza data.frame a la hora de representar datos en tablas. Sin embargo, estos son un poco antiguos y a veces se hace un poco engorroso trabajar con ellos. Tidyverse trata de solucionar esto empleando el paquete tibble . Los tibbles funcionan muy parecido a los data.frame , pero presentan caracter\u00edsticas que los hace mucho m\u00e1s sencillo trabajar con ellos: Son mucho m\u00e1s r\u00e1pidos . No transforman los vectores de caracteres a factores , cosa que s\u00ed ocurre con los data.frame . Son m\u00e1s reproducibles , es decir, es m\u00e1s probable que aquellos que trabajen con los mismos datos que t\u00fa lleguen a los mismos resultados. Podemos transformar cualquier data.frame en un tibble empleando as_tibble() . Empleemos esta funci\u00f3n con iris , un data.frame incluido en R: 1 as_tibble ( iris ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 150 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species <dbl> <dbl> <dbl> <dbl> <fct> 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 7 4.6 3.4 1.4 0.3 setosa 8 5 3.4 1.5 0.2 setosa 9 4.4 2.9 1.4 0.2 setosa 10 4.9 3.1 1.5 0.1 setosa # ... with 140 more rows Tambi\u00e9n puedes crear tus propios tibbles desde cero. Para ello, empleamos la funci\u00f3n tibble() , que construye las tablas por columnas. Por ejemplo: 1 2 3 4 5 tibble ( \"Columna 1\" = 1 : 5 , \"Columna 2\" = 2 , \"Columna 3\" = c ( 2 , 7 , 4 , 1 , 4 ), ) 1 2 3 4 5 6 7 8 # A tibble: 5 x 3 `Columna 1` `Columna 2` `Columna 3` <int> <dbl> <dbl> 1 1 2 2 2 2 2 7 3 3 2 4 4 4 2 1 5 5 2 4 Los tibbles ofrecen muchas posibilidades a la hora de crear tablas de datos. Si quieres saber m\u00e1s, puedes usar el comando ?tibble , o puedes consultar el manual oficial de Tidyverse aqu\u00ed .","title":"Tibbles"},{"location":"importar/#importando-datos","text":"Importar archivos de datos es muy sencillo, simplemente usa una de las siguientes funciones, dependiendo del tipo de delimitador por el que est\u00e9n separados tus datos: FUNCI\u00d3N DELIMITADOR read_csv() Coma read_csv2() Punto y coma read_tsv() Tabulaciones read_table() Espacio Razona: Encuentra un comando con el que puedas leer archivos con cualquier delimitador. Pista: Puedes revistar todos los comandos disponibles con ?read_delim Respuesta 1 read_delim ( < DATOS > , < DELIMITADOR > ) A partir de ahora, salvo excepciones, vamos a utilizar datos no incluidos dentro del paquete Tidyverse , empleando alguna de las funciones anteriores. Ejercicio Adelantemos un poco de trabajo. Abre y descarga este conjunto de datos y, teniendo en cuenta sus delimitadores, imp\u00f3rtalo a R. Respuesta Antes de bajarlo podemos comprobar que el archivo emplea tabulaciones como delimitadores. Por tanto, tras descargarlo en nuestro working directory , lo importamos y le asignamos la variable datos : 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver como nuestros datos ahora aparecen en la ventana environment , listos para ser usados:","title":"Importando datos"},{"location":"importar/#ejercicios-de-repaso","text":"Para ver si has entendido todo, intenta realizar los ejercicios propuestos en este enlace . Nota Cosulta el apartado \" Realizaci\u00f3n de ejercicios \" para saber como descargar, instalar y completar esta tarea.","title":"Ejercicios de repaso"},{"location":"importar/#referencias","text":"Referencias R for Data Science ; Hadley Wickham, Garrett Grolemund et al. Morphometric discrimination of two allozymically diagnosed sibling species ; Wayland, Matthew T. et al.","title":"Referencias"},{"location":"modelar/","text":"Introducci\u00f3n Modelar consiste en la aplicaci\u00f3n de herramientas matem\u00e1ticas para caracterizar un conjunto de datos y encontrar relaciones entre ellos, con las que somos capaces de: Predecir futuros resultados Encontrar patrones y diferencias entre variables Mejorar la visualizaci\u00f3n de los resultados A la hora de modelar, existen dos partes a seguir: Primero, debemos encontrar un patr\u00f3n dentro de los datos, que puede ser desde una relaci\u00f3n lineal simple ( y = a\u00b7 x + b) hasta una curva cuadr\u00e1tica ( y = a\u00b7 x ^b), siendo x e y las variables conocidas y \"a\" y \"b\" los par\u00e1metros que podemos modificar para encontrar la relaci\u00f3n. Tras esto, conociendo el patr\u00f3n, debemos encotrar el modelo que se ajusta a los datos (es decir, definir \"a\" y \"b\") Nota Hay que tener en cuenta que ning\u00fan modelo elegido es perfecto , simplemente es el que mejor se ajusta a los datos. Hay veces en el que el mejor modelo simplemente es malo y no tiene el porqu\u00e9 cumplirse en todos los casos. En esta parte del tutorial, adem\u00e1s de tidyverse , emplearemos el paquete modelr , incluido en R base y que nos dar\u00e1 algunas herramientas para comenzar a modelar. Adem\u00e1s, vamos a usar modeldata , que incluye una serie de conjuntos de datos preparados para aprender a modelar. Instalamos los paquetes y los cargamos: 1 install.packages ( \"modeldata\" ) 1 2 3 library ( tidyverse ) library ( modelr ) library ( modeldata ) Modelado b\u00e1sico Para este apartado, vamos a usar el conjunto de datos contenido en modeldata llamado \" oils \", que muestra las diferentes concentraciones de \u00e1cidos grasos en diferentes especies vegetales. 1 2 data ( oils ) View ( oils ) Para comenzar a modelar nos puede venir bien representar gr\u00e1ficamente los datos con los que queremos trabajar. Por ejemplo, imaginemos que necesitamos estudiar las concentraciones de \u00e1cido ol\u00e9ico con respecto a las de linoleico. Vamos a representar estas variables en un diagrama de dispersi\u00f3n: 1 2 ggplot ( data = oils ) + geom_point ( mapping = aes ( x = linoleic , y = oleic )) Vemos que hay una clara tendencia lineal entre las variables ( y = a\u00b7 x + b). Para elegir la recta que mejor se ajusta, podemos generar multitud de ellas y elegirla al verla en la gr\u00e1fica. Para ello, debemos generar rectas \"aleatorias\", para lo cual podemos usar la funcion runif para generar pendientes y puntos de corte con el eje y (es decir, \"a\" y \"b\" respectivamente) 1 runif ( < N\u00daMERO_DE_RECTAS > , min = , max = ) Generamos, por ejemplo, 200 rectas definiendo primero \"a\" y \"b\". Viendo la gr\u00e1fica, podemos deducir el punto de corte con el eje alrededor de 80 (entre 77 y 83) y la pendiente alrededor de 1 (entre -2 y 2): 1 2 3 4 ayb <- tibble ( a = runif ( 200 , -2 , 2 ), b = runif ( 200 , 77 , 83 ) ) Tras lo cual, representamos tanto las variables como las rectas, para lo cual usamos la funcion de ggplot2 llamada geom_abline : 1 geom_abline ( data = < DATOS > , aes ( slope = < PENDIENTE > , intercept = < CORTE_EJE_Y > ,)) 1 2 3 ggplot () + geom_abline ( data = ayb , mapping = aes ( slope = a , intercept = b ), alpha = 1 / 4 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Obtenemos algo parecido a esto: Vemos que la mayor\u00eda de l\u00edneas generadas est\u00e1n lejos de ajustarse a los datos. Para seleccionar las buenas es necesario calcular la distancia vertical entre los puntos y las l\u00edneas, para lo cual es necesario crear funciones. Este proceso es com\u00fan a la mayor\u00eda de diferentes modelados que podemos hacer sobre un set de datos. Este proceso puede ser tedioso y requiere de bastante experiencia en el tema, tarea a la cual el alumno de bioqu\u00edmica medio no esta acostumbrado. Por ello, en este tutorial promonemos una forma de entrar en el mundo del modelado de datos sin tener que lidiar con programaci\u00f3n demasiado compleja. Modelado de regresi\u00f3n lineal Por tanto, para est MJ: frase incompleta Antes de comenzar a estudiar la regresi\u00f3n lineal de nuestros datos, siempre es necesario hacer un test de correlaci\u00f3n de Pearson. Esto se hace f\u00e1cilmente empleando la funci\u00f3n cor.test() , de la siguiente forma: 1 cor.test ( x , y ) En nuestro caso, determinamos nuestras variables x e y indicando primero \" oils \" junto con el nombre de la variable empleando el s\u00edmbolo \" $ \": 1 2 3 4 5 6 7 8 9 10 11 12 cor.test ( oils $ oleic , oils $ linoleic ) Pearson ' s product-moment correlation data : oils $ oleic and oils $ linoleic t = -45.185 , df = 94 , p - value < 2.2e-16 alternative hypothesis : true correlation is not equal to 0 95 percent confidence interval : -0.9851233 -0.9667696 sample estimates : cor -0.9777453 El coeficiente de correlaci\u00f3n cercano al valor -1 nos indica que existe una fuerte correlaci\u00f3n lineal negativa, y el p -valor menor que 0.05 se\u00f1ala que el modelo lineal es v\u00e1lido. Ahora podemos plantear un modelo de regresi\u00f3n lineal con seguridad. Para ello, vamos a usar la funci\u00f3n lm() . Esta funci\u00f3n se usa de forma muy similar a la anterior: 1 lm ( y ~ x ) Definimos una variable para el modelo linear de nuestras variables de la siguiente forma: 1 2 regresion <- lm ( oils $ oleic ~ oils $ linoleic ) View ( regresion ) Para continuar con el analisis, hacemos un summary() a nuestra nueva variable, obteniendo lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 summary ( regresion ) Call : lm ( formula = oils $ oleic ~ oils $ linoleic ) Residuals : Min 1 Q Median 3 Q Max -7.1814 -1.6842 -0.0709 2.6859 5.0556 Coefficients : Estimate Std. Error t value Pr ( >| t | ) ( Intercept ) 79.35660 0.99614 79.66 < 2e-16 *** oils $ linoleic -0.91699 0.02029 -45.19 < 2e-16 *** --- Signif. codes : 0 \u2018 *** \u2019 0.001 \u2018 ** \u2019 0.01 \u2018 * \u2019 0.05 \u2018 . \u2019 0.1 \u2018 \u2019 1 Residual standard error : 3.133 on 94 degrees of freedom Multiple R - squared : 0.956 , Adjusted R - squared : 0.9555 F - statistic : 2042 on 1 and 94 DF , p - value : < 2.2e-16 Vemos como el R 2 obtenido es de 0.9555 , reafirmando la validez de nuestro modelo lineal. Podemos, finalmente, determinar cual es la l\u00ednea de ajuste de este conjunto de datos. Para ello, necesitamos los valores de pendiente y de corte con el eje y . Estos valores ya los hemos calculado al hacer el summary() , y se encuentran en el apartado coefficients : 1 2 3 4 regresion $ coefficients ( Intercept ) oils $ linoleic 79.3565958 -0.9169897 Nota Adem\u00e1s de para encontrar modelos lineales, lm() sirve para realizar cualquier tipo de regresi\u00f3n, an\u00e1lisis de varianza y covarianza y otros c\u00e1lculos estad\u00edsticos. Puedes profundizar m\u00e1s en c\u00f3mo usar esta funci\u00f3n aqu\u00ed . El valor de (Intercept) es el punto de corte con el eje y oils$linoleic es la pendiente. Sustituyendo estos valores en la ecuaci\u00f3n de la recta ( y = a\u00b7 x + b), obtenemos la l\u00ednea de regresi\u00f3n exacta para nuestros datos. Represent\u00e1ndola obtenemos: 1 2 3 4 5 6 a <- regresion $ coefficients [ 2 ] b <- regresion $ coefficients [ 1 ] ggplot () + geom_abline ( mapping = aes ( slope = a , intercept = b ), color = \"red\" , size = 1 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Referencias Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Tidy Modeling with R ; Max Kuhn, Julia Silge lm function: Fitting Linear Models","title":"Modelar datos"},{"location":"modelar/#introduccion","text":"Modelar consiste en la aplicaci\u00f3n de herramientas matem\u00e1ticas para caracterizar un conjunto de datos y encontrar relaciones entre ellos, con las que somos capaces de: Predecir futuros resultados Encontrar patrones y diferencias entre variables Mejorar la visualizaci\u00f3n de los resultados A la hora de modelar, existen dos partes a seguir: Primero, debemos encontrar un patr\u00f3n dentro de los datos, que puede ser desde una relaci\u00f3n lineal simple ( y = a\u00b7 x + b) hasta una curva cuadr\u00e1tica ( y = a\u00b7 x ^b), siendo x e y las variables conocidas y \"a\" y \"b\" los par\u00e1metros que podemos modificar para encontrar la relaci\u00f3n. Tras esto, conociendo el patr\u00f3n, debemos encotrar el modelo que se ajusta a los datos (es decir, definir \"a\" y \"b\") Nota Hay que tener en cuenta que ning\u00fan modelo elegido es perfecto , simplemente es el que mejor se ajusta a los datos. Hay veces en el que el mejor modelo simplemente es malo y no tiene el porqu\u00e9 cumplirse en todos los casos. En esta parte del tutorial, adem\u00e1s de tidyverse , emplearemos el paquete modelr , incluido en R base y que nos dar\u00e1 algunas herramientas para comenzar a modelar. Adem\u00e1s, vamos a usar modeldata , que incluye una serie de conjuntos de datos preparados para aprender a modelar. Instalamos los paquetes y los cargamos: 1 install.packages ( \"modeldata\" ) 1 2 3 library ( tidyverse ) library ( modelr ) library ( modeldata )","title":"Introducci\u00f3n"},{"location":"modelar/#modelado-basico","text":"Para este apartado, vamos a usar el conjunto de datos contenido en modeldata llamado \" oils \", que muestra las diferentes concentraciones de \u00e1cidos grasos en diferentes especies vegetales. 1 2 data ( oils ) View ( oils ) Para comenzar a modelar nos puede venir bien representar gr\u00e1ficamente los datos con los que queremos trabajar. Por ejemplo, imaginemos que necesitamos estudiar las concentraciones de \u00e1cido ol\u00e9ico con respecto a las de linoleico. Vamos a representar estas variables en un diagrama de dispersi\u00f3n: 1 2 ggplot ( data = oils ) + geom_point ( mapping = aes ( x = linoleic , y = oleic )) Vemos que hay una clara tendencia lineal entre las variables ( y = a\u00b7 x + b). Para elegir la recta que mejor se ajusta, podemos generar multitud de ellas y elegirla al verla en la gr\u00e1fica. Para ello, debemos generar rectas \"aleatorias\", para lo cual podemos usar la funcion runif para generar pendientes y puntos de corte con el eje y (es decir, \"a\" y \"b\" respectivamente) 1 runif ( < N\u00daMERO_DE_RECTAS > , min = , max = ) Generamos, por ejemplo, 200 rectas definiendo primero \"a\" y \"b\". Viendo la gr\u00e1fica, podemos deducir el punto de corte con el eje alrededor de 80 (entre 77 y 83) y la pendiente alrededor de 1 (entre -2 y 2): 1 2 3 4 ayb <- tibble ( a = runif ( 200 , -2 , 2 ), b = runif ( 200 , 77 , 83 ) ) Tras lo cual, representamos tanto las variables como las rectas, para lo cual usamos la funcion de ggplot2 llamada geom_abline : 1 geom_abline ( data = < DATOS > , aes ( slope = < PENDIENTE > , intercept = < CORTE_EJE_Y > ,)) 1 2 3 ggplot () + geom_abline ( data = ayb , mapping = aes ( slope = a , intercept = b ), alpha = 1 / 4 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic )) Obtenemos algo parecido a esto: Vemos que la mayor\u00eda de l\u00edneas generadas est\u00e1n lejos de ajustarse a los datos. Para seleccionar las buenas es necesario calcular la distancia vertical entre los puntos y las l\u00edneas, para lo cual es necesario crear funciones. Este proceso es com\u00fan a la mayor\u00eda de diferentes modelados que podemos hacer sobre un set de datos. Este proceso puede ser tedioso y requiere de bastante experiencia en el tema, tarea a la cual el alumno de bioqu\u00edmica medio no esta acostumbrado. Por ello, en este tutorial promonemos una forma de entrar en el mundo del modelado de datos sin tener que lidiar con programaci\u00f3n demasiado compleja.","title":"Modelado b\u00e1sico"},{"location":"modelar/#modelado-de-regresion-lineal","text":"Por tanto, para est MJ: frase incompleta Antes de comenzar a estudiar la regresi\u00f3n lineal de nuestros datos, siempre es necesario hacer un test de correlaci\u00f3n de Pearson. Esto se hace f\u00e1cilmente empleando la funci\u00f3n cor.test() , de la siguiente forma: 1 cor.test ( x , y ) En nuestro caso, determinamos nuestras variables x e y indicando primero \" oils \" junto con el nombre de la variable empleando el s\u00edmbolo \" $ \": 1 2 3 4 5 6 7 8 9 10 11 12 cor.test ( oils $ oleic , oils $ linoleic ) Pearson ' s product-moment correlation data : oils $ oleic and oils $ linoleic t = -45.185 , df = 94 , p - value < 2.2e-16 alternative hypothesis : true correlation is not equal to 0 95 percent confidence interval : -0.9851233 -0.9667696 sample estimates : cor -0.9777453 El coeficiente de correlaci\u00f3n cercano al valor -1 nos indica que existe una fuerte correlaci\u00f3n lineal negativa, y el p -valor menor que 0.05 se\u00f1ala que el modelo lineal es v\u00e1lido. Ahora podemos plantear un modelo de regresi\u00f3n lineal con seguridad. Para ello, vamos a usar la funci\u00f3n lm() . Esta funci\u00f3n se usa de forma muy similar a la anterior: 1 lm ( y ~ x ) Definimos una variable para el modelo linear de nuestras variables de la siguiente forma: 1 2 regresion <- lm ( oils $ oleic ~ oils $ linoleic ) View ( regresion ) Para continuar con el analisis, hacemos un summary() a nuestra nueva variable, obteniendo lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 summary ( regresion ) Call : lm ( formula = oils $ oleic ~ oils $ linoleic ) Residuals : Min 1 Q Median 3 Q Max -7.1814 -1.6842 -0.0709 2.6859 5.0556 Coefficients : Estimate Std. Error t value Pr ( >| t | ) ( Intercept ) 79.35660 0.99614 79.66 < 2e-16 *** oils $ linoleic -0.91699 0.02029 -45.19 < 2e-16 *** --- Signif. codes : 0 \u2018 *** \u2019 0.001 \u2018 ** \u2019 0.01 \u2018 * \u2019 0.05 \u2018 . \u2019 0.1 \u2018 \u2019 1 Residual standard error : 3.133 on 94 degrees of freedom Multiple R - squared : 0.956 , Adjusted R - squared : 0.9555 F - statistic : 2042 on 1 and 94 DF , p - value : < 2.2e-16 Vemos como el R 2 obtenido es de 0.9555 , reafirmando la validez de nuestro modelo lineal. Podemos, finalmente, determinar cual es la l\u00ednea de ajuste de este conjunto de datos. Para ello, necesitamos los valores de pendiente y de corte con el eje y . Estos valores ya los hemos calculado al hacer el summary() , y se encuentran en el apartado coefficients : 1 2 3 4 regresion $ coefficients ( Intercept ) oils $ linoleic 79.3565958 -0.9169897 Nota Adem\u00e1s de para encontrar modelos lineales, lm() sirve para realizar cualquier tipo de regresi\u00f3n, an\u00e1lisis de varianza y covarianza y otros c\u00e1lculos estad\u00edsticos. Puedes profundizar m\u00e1s en c\u00f3mo usar esta funci\u00f3n aqu\u00ed . El valor de (Intercept) es el punto de corte con el eje y oils$linoleic es la pendiente. Sustituyendo estos valores en la ecuaci\u00f3n de la recta ( y = a\u00b7 x + b), obtenemos la l\u00ednea de regresi\u00f3n exacta para nuestros datos. Represent\u00e1ndola obtenemos: 1 2 3 4 5 6 a <- regresion $ coefficients [ 2 ] b <- regresion $ coefficients [ 1 ] ggplot () + geom_abline ( mapping = aes ( slope = a , intercept = b ), color = \"red\" , size = 1 ) + geom_point ( data = oils , mapping = aes ( x = linoleic , y = oleic ))","title":"Modelado de regresi\u00f3n lineal"},{"location":"modelar/#referencias","text":"Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Tidy Modeling with R ; Max Kuhn, Julia Silge lm function: Fitting Linear Models","title":"Referencias"},{"location":"ordenar/","text":"Introducci\u00f3n Ahora que sabemos importar nuestros datos crudos, el siguiente paso es transformarlos en algo manejable. Para este apartado, vamos a usar nuestro propio set de datos: brca.txt , que contiene informaci\u00f3n anal\u00edtica sobre diferentes casos de c\u00e1ncer de mama, como por ejemplo la edad del paciente, subtipo cl\u00ednico, subtipo molecular, n\u00famero de ganglios linf\u00e1ticos, radioterapia, etc. (puedes obtener el fichero original aqu\u00ed ). Adem\u00e1s, vamos a emplear un paquete de funciones nuevo, hablar , que no viene incluido ni en Tidyverse ni en R base. Este contiene una funci\u00f3n muy \u00fatil que nos permite cambiar el tipo de dato asignado a una variable, asunto que veremos m\u00e1s adelante en el tutorial (puedes encontrar m\u00e1s informaci\u00f3n aqu\u00ed ). Lo instalamos y cargamos los paquetes Tidyverse y hablar : 1 2 3 install.packages ( \"hablar\" ) library ( tidyverse ) library ( hablar ) Una vez cargados los paquetes y descargado el archivo (que emplea tabulaciones como delimitadores), lo abrimos y le asignamos una variable: 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver el dataset en la consola simplemente escribiendo el nombre de la variable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 > datos # A tibble: 11 x 1,098 attrib_name TCGA.3C.AAAU TCGA.3C.AALI TCGA.3C.AALJ TCGA.3C.AALK TCGA.4H.AAAK TCGA.5L.AAT0 < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_to_bir ~ 55 50 62 52 50 42 2 Tumor_purity 0.7886 0.6974 0.7666 0.6869 0.649 0.6501 3 pathologic_s ~ NA 2 2 1 3 2 4 histological ~ infiltratingl ~ infiltratingd ~ infiltratingd ~ infiltratingd ~ infiltrating ~ infiltrating ~ 5 number_of_ly ~ 4 1 1 0 4 0 6 gender female female female female female female 7 radiation_th ~ no yes no no no yes 8 race white blackorafrica ~ blackorafrica ~ blackorafrica ~ white white 9 ethnicity nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanico ~ hispanicorla ~ 10 Median_overa ~ 1 1 0 0 0 0 11 overall_surv ~ 4047 4005 1474 1448 348 1477 # ... with 1,091 more variables: TCGA.5L.AAT1 <chr>, TCGA.5T.A9QA <chr>, TCGA.A1.A0SB <chr>,... Para verlos en forma de tabla empleamos: 1 View ( datos ) Debe aparecer algo similar a esto: Orientaci\u00f3n de los datos Para considerar que un conjunto de datos est\u00e1 correctamente ordenado, este debe cumplir al menos las siguientes tres reglas: Cada variable debe tener su propia columna Cada caso debe tener su propia fila Cada valor debe tener su propia celda Lo primero de lo que podemos darnos cuenta es que la orientaci\u00f3n de nuestro conjunto de datos es incorrecta, pues se muestran las variables en las filas y los diferentes casos en las columnas. Esto puede solucionarse f\u00e1cilmente transponiendo las filas y columnas. Sin embargo, Tidyverse no ofrece ninguna funci\u00f3n para transponer tibbles . Por tanto, tenemos que usar la funcion t() , incluida en R base: 1 t ( datos ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [, 1 ] [, 2 ] [, 3 ] [, 4 ] attrib_name \"years_to_birth\" \"Tumor_purity\" \"pathologic_stage\" \"histological_type\" TCGA.3C.AAAU \"55\" \"0.7886\" NA \"infiltratinglobularcarcinoma\" TCGA.3C.AALI \"50\" \"0.6974\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALJ \"62\" \"0.7666\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALK \"52\" \"0.6869\" \"1\" \"infiltratingductalcarcinoma\" TCGA.4H.AAAK \"50\" \"0.649\" \"3\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT0 \"42\" \"0.6501\" \"2\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT1 \"63\" \"0.5553\" \"4\" \"infiltratinglobularcarcinoma\" TCGA.5T.A9QA \"52\" \"0.8368\" \"2\" \"other,specify\" TCGA.A1.A0SB \"70\" \"0.9328\" \"1\" \"other,specify\" TCGA.A1.A0SD \"59\" \"0.6906\" \"2\" \"infiltratingductalcarcinoma\" TCGA.A1.A0SE \"56\" \"0.7979\" \"1\" \"mixedhistology(pleasespecify)\" TCGA.A1.A0SF \"54\" \"0.7237\" \"2\" \"infiltratingductalcarcinoma\" ... Esta funci\u00f3n, sin embargo, transforma las tibbles en matrices de R est\u00e1ndar. Esto tambi\u00e9n puede solucionarse f\u00e1cilmente usando as_tibble() . Vamos a definir una nueva variable para diferenciar los datos originales (variable datos ) de los bien ordenados con los que vamos a trabajar a partir de ahora (variable brca ): 1 brca <- as_tibble ( t ( datos ), rownames = NA ) Nota Con rownames = NA evitamos que se elimine la columna de nombres de los diferentes casos. 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 1,098 x 10 V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 * < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_t ~ Tumor_p ~ patholog ~ histologica ~ number_o ~ gender_and ~ radiati ~ ethnicity Median_ov ~ overall ~ 2 55 0.7886 NA infiltratin ~ 4 female / whi ~ no nothispa ~ 1 4047 3 50 0.6974 2 infiltratin ~ 1 female / bla ~ yes nothispa ~ 1 4005 4 62 0.7666 2 infiltratin ~ 1 female / bla ~ no nothispa ~ 0 1474 5 52 0.6869 1 infiltratin ~ 0 female / bla ~ no nothispa ~ 0 1448 6 50 0.649 3 infiltratin ~ 4 female / whi ~ no nothispa ~ 0 348 7 42 0.6501 2 infiltratin ~ 0 female / whi ~ yes hispanic ~ 0 1477 8 63 0.5553 4 infiltratin ~ 0 female / whi ~ no hispanic ~ 0 1471 9 52 0.8368 2 other , speci ~ NA female / bla ~ yes nothispa ~ 0 303 10 70 0.9328 1 other , speci ~ 0 female / whi ~ NA nothispa ~ 0 259 # ... with 1,088 more rows Vemos que esta funci\u00f3n ha asignado nombres predeterminados a las columnas traspuestas ( V1 , V2 , V3 ...), dejando los nombres originales en una fila aparte. Corregimos los nombres y eliminamos la fila sobrante: 1 2 colnames ( brca ) <- brca [ 1 ,] brca <- brca [ - c ( 1 ),] 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Los datos quedar\u00edan finalmente de la siguiente forma: 1 View ( brca ) Importante: Vamos a usar estos datos modificados brca hasta el final del apartado. Es posible que no funcione alg\u00fan ejercicio si no hab\u00e9is seguido los pasos que hemos hecho hasta ahora. Modificar datos Ahora que los datos se encuentran bien orientados, es m\u00e1s f\u00e1cil ver los resultados y pensar qu\u00e9 modificaciones podemos hacer. Nota Ya hemos estudiado la manipulaci\u00f3n b\u00e1sica de data frames en el tutorial b\u00e1sico anterior. Puedes mirarlo aqu\u00ed . Combinar columnas Tidyverse ofrece una herramienta que nos permite unir variables en una sola columna en caso de que lo necesitemos. Para ello, empleamos el comando unite() , de la siguiente forma: 1 unite ( < DATOS > , < COL_NUEVA > , < COLUMNA1 > , < COLUMNA2 > , ... , sep = \"<SEPARADOR>\" ) Por ejemplo, imaginemos que necesitamos en una sola columna a edad del paciente y la pureza del tumor: 1 ejemplo1 <- unite ( brca , ejemplo1 , years_to_birth , Tumor_purity , sep = \" - \" ) 1 ejemplo1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 9 ejemplo1 pathologic_stage histological_type number_of_lymph_ ~ gender_and_race radiation_thera ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7 ~ NA infiltratinglobular ~ 4 female / white no 2 50 - 0.6 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ yes 3 62 - 0.7 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ no 4 52 - 0.6 ~ 1 infiltratingductalc ~ 0 female / blackorafr ~ no 5 50 - 0.6 ~ 3 infiltratinglobular ~ 4 female / white no 6 42 - 0.6 ~ 2 infiltratinglobular ~ 0 female / white yes 7 63 - 0.5 ~ 4 infiltratinglobular ~ 0 female / white no 8 52 - 0.8 ~ 2 other , specify NA female / blackorafr ~ yes 9 70 - 0.9 ~ 1 other , specify 0 female / white NA 10 59 - 0.6 ~ 2 infiltratingductalc ~ 0 female / white NA # ... with 1,087 more rows, and 3 more variables: ethnicity <chr>, Median_overall_survival <chr>, # overall_survival <chr> Si no queremos eliminar las columnas originales, a\u00f1adimos remove = FALSE al comando: 1 ejemplo2 <- unite ( brca , ejemplo2 , years_to_birth , Tumor_purity , sep = \" - \" , remove = FALSE ) 1 ejemplo2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 ejemplo2 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_no ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7886 55 0.7886 NA infiltratinglobularcarc ~ 4 2 50 - 0.6974 50 0.6974 2 infiltratingductalcarci ~ 1 3 62 - 0.7666 62 0.7666 2 infiltratingductalcarci ~ 1 4 52 - 0.6869 52 0.6869 1 infiltratingductalcarci ~ 0 5 50 - 0.649 50 0.649 3 infiltratinglobularcarc ~ 4 6 42 - 0.6501 42 0.6501 2 infiltratinglobularcarc ~ 0 7 63 - 0.5553 63 0.5553 4 infiltratinglobularcarc ~ 0 8 52 - 0.8368 52 0.8368 2 other , specify NA 9 70 - 0.9328 70 0.9328 1 other , specify 0 10 59 - 0.6906 59 0.6906 2 infiltratingductalcarci ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr> Ejercicio Prueba a combinar las variables pathologic_stage y radiation_therapy en una nueva columna llamada treatment_urgency , usando como separador \" & \" y sin eliminar las columnas originales. Respuesta 1 2 3 4 5 ejercicio1 <- unite ( brca , treatment_urgency , pathologic_stage , radiation_therapy , sep = \" & \" , remove = FALSE ) 1 ejercicio1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity treatment_urgency pathologic_stage histological_type number_of_lymph_ ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA & no NA infiltratinglobular ~ 4 2 50 0.6974 2 & yes 2 infiltratingductalc ~ 1 3 62 0.7666 2 & no 2 infiltratingductalc ~ 1 4 52 0.6869 1 & no 1 infiltratingductalc ~ 0 5 50 0.649 3 & no 3 infiltratinglobular ~ 4 6 42 0.6501 2 & yes 2 infiltratinglobular ~ 0 7 63 0.5553 4 & no 4 infiltratinglobular ~ 0 8 52 0.8368 2 & yes 2 other , specify NA 9 70 0.9328 1 & NA 1 other , specify 0 10 59 0.6906 2 & NA 2 infiltratingductalc ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr> Separar columnas De la misma forma, podemos separar columnas f\u00e1cilmente empleando separate() : 1 separate ( < DATOS > , < NOMBRE_COLUMNA > , into = c ( \"<COL_NUEVA_1>\" , \"<COL_NUEVA_2>\" ), sep = \"<SEPARADOR>\" ) Esta funci\u00f3n es muy \u00fatil, pues permite separar las columnas empleando cualquier tipo de caracter como separador. Por ejemplo, en nuestro set de datos encontramos las variables \"g\u00e9nero\" y \"raza\" en una misma columna llamada gender_and_race . Vamos a separarlas: 1 ejemplo3 <- separate ( brca , gender_and_race , into = c ( \"gender\" , \"race\" ), sep = \"/\" ) 1 ejemplo3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender race < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobular ~ 4 female white 2 50 0.6974 2 infiltratingductalc ~ 1 female blackoraf ~ 3 62 0.7666 2 infiltratingductalc ~ 1 female blackoraf ~ 4 52 0.6869 1 infiltratingductalc ~ 0 female blackoraf ~ 5 50 0.649 3 infiltratinglobular ~ 4 female white 6 42 0.6501 2 infiltratinglobular ~ 0 female white 7 63 0.5553 4 infiltratinglobular ~ 0 female white 8 52 0.8368 2 other , specify NA female blackoraf ~ 9 70 0.9328 1 other , specify 0 female white 10 59 0.6906 2 infiltratingductalc ~ 0 female white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Reordenar columnas Normalmente las variables se organizan de forma que aquellas que son m\u00e1s importantes se encuentran m\u00e1s hacia la izquierda. Trabajando podemos estimar que alguna variable es la m\u00e1s importante en nuestro caso y queremos que sea la que ocupa la primera columna. Esto es muy sencillo de arreglar empleando la funci\u00f3n relocate() : 1 relocate ( < DATOS > , < VARIABLE > ) Por ejemplo, mirando nuestros datos ordenados estimamos que la variable \" histological_type \" es la m\u00e1s importante para nuestro estudio. La reordenamos de la siguiente forma: 1 ejemplo4 <- relocate ( brca , histological_type ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 histological_type years_to_birth Tumor_purity pathologic_stage number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 infiltratinglobula ~ 55 0.7886 NA 4 female / white 2 infiltratingductal ~ 50 0.6974 2 1 female / blackorafr ~ 3 infiltratingductal ~ 62 0.7666 2 1 female / blackorafr ~ 4 infiltratingductal ~ 52 0.6869 1 0 female / blackorafr ~ 5 infiltratinglobula ~ 50 0.649 3 4 female / white 6 infiltratinglobula ~ 42 0.6501 2 0 female / white 7 infiltratinglobula ~ 63 0.5553 4 0 female / white 8 other , specify 52 0.8368 2 NA female / blackorafr ~ 9 other , specify 70 0.9328 1 0 female / white 10 infiltratingductal ~ 59 0.6906 2 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Ejercicio Con esta funci\u00f3n podemos colocar las columnas en las posiciones que queramos, no solamente en la primera columna. Intenta mover la variable \" ethnicity \" a la 3\u00aa columna. Pista 1 Puedes usar alguno de estos dos comandos dentro de relocate() : .before = o .after = . Pista 2 Prueba a usar: 1 2 3 4 relocate ( < DATOS > , < VARIABLE > , .before = < VARIABLE_ANTES > , .after = < VARIABLE_DESPUES > ) Respuesta 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .before = pathologic_stage ) Tambi\u00e9n sirve: 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .after = Tumor_purity ) En ambos casos obtenemos: 1 ejercicio2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity ethnicity pathologic_stage histological_type number_of_lymph_n ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 nothispanicor ~ NA infiltratinglobularca ~ 4 2 50 0.6974 nothispanicor ~ 2 infiltratingductalcar ~ 1 3 62 0.7666 nothispanicor ~ 2 infiltratingductalcar ~ 1 4 52 0.6869 nothispanicor ~ 1 infiltratingductalcar ~ 0 5 50 0.649 nothispanicor ~ 3 infiltratinglobularca ~ 4 6 42 0.6501 hispanicorlat ~ 2 infiltratinglobularca ~ 0 7 63 0.5553 hispanicorlat ~ 4 infiltratinglobularca ~ 0 8 52 0.8368 nothispanicor ~ 2 other , specify NA 9 70 0.9328 nothispanicor ~ 1 other , specify 0 10 59 0.6906 nothispanicor ~ 2 infiltratingductalcar ~ 0 # ... with 1,087 more rows, and 4 more variables: gender_and_race <chr>, radiation_therapy <chr>, # Median_overall_survival <chr>, overall_survival <chr> Cambiar tipo de datos Al importar los datos, transformarlos a tibble y modificarlos hemos cambiado su naturaleza (esto se ve debajo de los nombres de las columnas). Esto, a la hora de realizar c\u00e1lculos estadisticos, modificaciones m\u00e1s complejas y representaciones gr\u00e1ficas puede darnos problemas, por lo que es conveniente transormarlos al tipo de dato correspondiente. Nota Es necesario antes conocer qu\u00e9 significan cada una de las funciones de conversi\u00f3n de datos. A continuaci\u00f3n, se muestran las m\u00e1s comunes: FUNCIONES TIPO DE DATO <chr> Car\u00e1cter <num> Num\u00e9rico <int> Entero <lgl> L\u00f3gico <fct> Factor <dte> Fecha <dtm> Fecha y hora <dbl> Decimales Usemos de nuevo nuestros datos. Muchas de nuestras variables son num\u00e9ricas. Sin embargo, a todas se les ha asignado el tipo car\u00e1cter. Podemos arreglar esto empleando la funci\u00f3n convert() , perteneciente al paquete de datos hablar : 1 convert ( < DATOS > , < FUNCI\u00d3N_CONVERSI\u00d3N > ( < COLUMNAS > )) Vemos que muchas de las variables ( years_to_birth , number_of_lymph_nodes , Median_overall_survival y overall_survival ) son n\u00fameros enteros ( <int> ) pero est\u00e1n clasificados como car\u00e1cter ( <chr> ). Arreglamos esto de forma sencilla: 1 2 3 4 5 6 7 ejemplo4 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ) ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < chr > < chr > < chr > < int > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> Podemos aplicar varios tipos de datos a diferentes variables. Por ejemplo, la variable Tumor_purity es una variable decimal ( <dbl> ): 1 2 3 4 5 6 7 8 9 10 11 ejemplo5 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ), dbl ( Tumor_purity ) ) 1 ejemplo5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < dbl > < chr > < chr > < int > < chr > 1 55 0.789 NA infiltratinglobula ~ 4 female / white 2 50 0.697 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.767 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.687 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.650 2 infiltratinglobula ~ 0 female / white 7 63 0.555 4 infiltratinglobula ~ 0 female / white 8 52 0.837 2 other , specify NA female / blackorafr ~ 9 70 0.933 1 other , specify 0 female / white 10 59 0.691 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> De esta forma hemos solucionado muchos problemas en el futuro por trabajar con datos err\u00f3neamentes clasificados. Ejercicios de repaso Para ver si has entendido todo, intenta realizar los ejercicios propuestos en este enlace . Nota Cosulta el apartado \" Realizaci\u00f3n de ejercicios \" para saber como descargar, instalar y completar esta tarea. Referencias Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Suppl. Ch. 2: Import and Tidy Data ; Gabriel Odom Data import: cheat sheet ; Garrett Grolemund A grammer for data type conversion ; David Sjoberg Change column order: relocate LinkedOmics Data Download","title":"Ordenar datos"},{"location":"ordenar/#introduccion","text":"Ahora que sabemos importar nuestros datos crudos, el siguiente paso es transformarlos en algo manejable. Para este apartado, vamos a usar nuestro propio set de datos: brca.txt , que contiene informaci\u00f3n anal\u00edtica sobre diferentes casos de c\u00e1ncer de mama, como por ejemplo la edad del paciente, subtipo cl\u00ednico, subtipo molecular, n\u00famero de ganglios linf\u00e1ticos, radioterapia, etc. (puedes obtener el fichero original aqu\u00ed ). Adem\u00e1s, vamos a emplear un paquete de funciones nuevo, hablar , que no viene incluido ni en Tidyverse ni en R base. Este contiene una funci\u00f3n muy \u00fatil que nos permite cambiar el tipo de dato asignado a una variable, asunto que veremos m\u00e1s adelante en el tutorial (puedes encontrar m\u00e1s informaci\u00f3n aqu\u00ed ). Lo instalamos y cargamos los paquetes Tidyverse y hablar : 1 2 3 install.packages ( \"hablar\" ) library ( tidyverse ) library ( hablar ) Una vez cargados los paquetes y descargado el archivo (que emplea tabulaciones como delimitadores), lo abrimos y le asignamos una variable: 1 datos <- read_tsv ( \"brca.txt\" ) Podemos ver el dataset en la consola simplemente escribiendo el nombre de la variable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 > datos # A tibble: 11 x 1,098 attrib_name TCGA.3C.AAAU TCGA.3C.AALI TCGA.3C.AALJ TCGA.3C.AALK TCGA.4H.AAAK TCGA.5L.AAT0 < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_to_bir ~ 55 50 62 52 50 42 2 Tumor_purity 0.7886 0.6974 0.7666 0.6869 0.649 0.6501 3 pathologic_s ~ NA 2 2 1 3 2 4 histological ~ infiltratingl ~ infiltratingd ~ infiltratingd ~ infiltratingd ~ infiltrating ~ infiltrating ~ 5 number_of_ly ~ 4 1 1 0 4 0 6 gender female female female female female female 7 radiation_th ~ no yes no no no yes 8 race white blackorafrica ~ blackorafrica ~ blackorafrica ~ white white 9 ethnicity nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanicor ~ nothispanico ~ hispanicorla ~ 10 Median_overa ~ 1 1 0 0 0 0 11 overall_surv ~ 4047 4005 1474 1448 348 1477 # ... with 1,091 more variables: TCGA.5L.AAT1 <chr>, TCGA.5T.A9QA <chr>, TCGA.A1.A0SB <chr>,... Para verlos en forma de tabla empleamos: 1 View ( datos ) Debe aparecer algo similar a esto:","title":"Introducci\u00f3n"},{"location":"ordenar/#orientacion-de-los-datos","text":"Para considerar que un conjunto de datos est\u00e1 correctamente ordenado, este debe cumplir al menos las siguientes tres reglas: Cada variable debe tener su propia columna Cada caso debe tener su propia fila Cada valor debe tener su propia celda Lo primero de lo que podemos darnos cuenta es que la orientaci\u00f3n de nuestro conjunto de datos es incorrecta, pues se muestran las variables en las filas y los diferentes casos en las columnas. Esto puede solucionarse f\u00e1cilmente transponiendo las filas y columnas. Sin embargo, Tidyverse no ofrece ninguna funci\u00f3n para transponer tibbles . Por tanto, tenemos que usar la funcion t() , incluida en R base: 1 t ( datos ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [, 1 ] [, 2 ] [, 3 ] [, 4 ] attrib_name \"years_to_birth\" \"Tumor_purity\" \"pathologic_stage\" \"histological_type\" TCGA.3C.AAAU \"55\" \"0.7886\" NA \"infiltratinglobularcarcinoma\" TCGA.3C.AALI \"50\" \"0.6974\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALJ \"62\" \"0.7666\" \"2\" \"infiltratingductalcarcinoma\" TCGA.3C.AALK \"52\" \"0.6869\" \"1\" \"infiltratingductalcarcinoma\" TCGA.4H.AAAK \"50\" \"0.649\" \"3\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT0 \"42\" \"0.6501\" \"2\" \"infiltratinglobularcarcinoma\" TCGA.5L.AAT1 \"63\" \"0.5553\" \"4\" \"infiltratinglobularcarcinoma\" TCGA.5T.A9QA \"52\" \"0.8368\" \"2\" \"other,specify\" TCGA.A1.A0SB \"70\" \"0.9328\" \"1\" \"other,specify\" TCGA.A1.A0SD \"59\" \"0.6906\" \"2\" \"infiltratingductalcarcinoma\" TCGA.A1.A0SE \"56\" \"0.7979\" \"1\" \"mixedhistology(pleasespecify)\" TCGA.A1.A0SF \"54\" \"0.7237\" \"2\" \"infiltratingductalcarcinoma\" ... Esta funci\u00f3n, sin embargo, transforma las tibbles en matrices de R est\u00e1ndar. Esto tambi\u00e9n puede solucionarse f\u00e1cilmente usando as_tibble() . Vamos a definir una nueva variable para diferenciar los datos originales (variable datos ) de los bien ordenados con los que vamos a trabajar a partir de ahora (variable brca ): 1 brca <- as_tibble ( t ( datos ), rownames = NA ) Nota Con rownames = NA evitamos que se elimine la columna de nombres de los diferentes casos. 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # A tibble: 1,098 x 10 V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 * < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 years_t ~ Tumor_p ~ patholog ~ histologica ~ number_o ~ gender_and ~ radiati ~ ethnicity Median_ov ~ overall ~ 2 55 0.7886 NA infiltratin ~ 4 female / whi ~ no nothispa ~ 1 4047 3 50 0.6974 2 infiltratin ~ 1 female / bla ~ yes nothispa ~ 1 4005 4 62 0.7666 2 infiltratin ~ 1 female / bla ~ no nothispa ~ 0 1474 5 52 0.6869 1 infiltratin ~ 0 female / bla ~ no nothispa ~ 0 1448 6 50 0.649 3 infiltratin ~ 4 female / whi ~ no nothispa ~ 0 348 7 42 0.6501 2 infiltratin ~ 0 female / whi ~ yes hispanic ~ 0 1477 8 63 0.5553 4 infiltratin ~ 0 female / whi ~ no hispanic ~ 0 1471 9 52 0.8368 2 other , speci ~ NA female / bla ~ yes nothispa ~ 0 303 10 70 0.9328 1 other , speci ~ 0 female / whi ~ NA nothispa ~ 0 259 # ... with 1,088 more rows Vemos que esta funci\u00f3n ha asignado nombres predeterminados a las columnas traspuestas ( V1 , V2 , V3 ...), dejando los nombres originales en una fila aparte. Corregimos los nombres y eliminamos la fila sobrante: 1 2 colnames ( brca ) <- brca [ 1 ,] brca <- brca [ - c ( 1 ),] 1 brca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Los datos quedar\u00edan finalmente de la siguiente forma: 1 View ( brca ) Importante: Vamos a usar estos datos modificados brca hasta el final del apartado. Es posible que no funcione alg\u00fan ejercicio si no hab\u00e9is seguido los pasos que hemos hecho hasta ahora.","title":"Orientaci\u00f3n de los datos"},{"location":"ordenar/#modificar-datos","text":"Ahora que los datos se encuentran bien orientados, es m\u00e1s f\u00e1cil ver los resultados y pensar qu\u00e9 modificaciones podemos hacer. Nota Ya hemos estudiado la manipulaci\u00f3n b\u00e1sica de data frames en el tutorial b\u00e1sico anterior. Puedes mirarlo aqu\u00ed .","title":"Modificar datos"},{"location":"ordenar/#combinar-columnas","text":"Tidyverse ofrece una herramienta que nos permite unir variables en una sola columna en caso de que lo necesitemos. Para ello, empleamos el comando unite() , de la siguiente forma: 1 unite ( < DATOS > , < COL_NUEVA > , < COLUMNA1 > , < COLUMNA2 > , ... , sep = \"<SEPARADOR>\" ) Por ejemplo, imaginemos que necesitamos en una sola columna a edad del paciente y la pureza del tumor: 1 ejemplo1 <- unite ( brca , ejemplo1 , years_to_birth , Tumor_purity , sep = \" - \" ) 1 ejemplo1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 9 ejemplo1 pathologic_stage histological_type number_of_lymph_ ~ gender_and_race radiation_thera ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7 ~ NA infiltratinglobular ~ 4 female / white no 2 50 - 0.6 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ yes 3 62 - 0.7 ~ 2 infiltratingductalc ~ 1 female / blackorafr ~ no 4 52 - 0.6 ~ 1 infiltratingductalc ~ 0 female / blackorafr ~ no 5 50 - 0.6 ~ 3 infiltratinglobular ~ 4 female / white no 6 42 - 0.6 ~ 2 infiltratinglobular ~ 0 female / white yes 7 63 - 0.5 ~ 4 infiltratinglobular ~ 0 female / white no 8 52 - 0.8 ~ 2 other , specify NA female / blackorafr ~ yes 9 70 - 0.9 ~ 1 other , specify 0 female / white NA 10 59 - 0.6 ~ 2 infiltratingductalc ~ 0 female / white NA # ... with 1,087 more rows, and 3 more variables: ethnicity <chr>, Median_overall_survival <chr>, # overall_survival <chr> Si no queremos eliminar las columnas originales, a\u00f1adimos remove = FALSE al comando: 1 ejemplo2 <- unite ( brca , ejemplo2 , years_to_birth , Tumor_purity , sep = \" - \" , remove = FALSE ) 1 ejemplo2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 ejemplo2 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_no ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 - 0.7886 55 0.7886 NA infiltratinglobularcarc ~ 4 2 50 - 0.6974 50 0.6974 2 infiltratingductalcarci ~ 1 3 62 - 0.7666 62 0.7666 2 infiltratingductalcarci ~ 1 4 52 - 0.6869 52 0.6869 1 infiltratingductalcarci ~ 0 5 50 - 0.649 50 0.649 3 infiltratinglobularcarc ~ 4 6 42 - 0.6501 42 0.6501 2 infiltratinglobularcarc ~ 0 7 63 - 0.5553 63 0.5553 4 infiltratinglobularcarc ~ 0 8 52 - 0.8368 52 0.8368 2 other , specify NA 9 70 - 0.9328 70 0.9328 1 other , specify 0 10 59 - 0.6906 59 0.6906 2 infiltratingductalcarci ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr> Ejercicio Prueba a combinar las variables pathologic_stage y radiation_therapy en una nueva columna llamada treatment_urgency , usando como separador \" & \" y sin eliminar las columnas originales. Respuesta 1 2 3 4 5 ejercicio1 <- unite ( brca , treatment_urgency , pathologic_stage , radiation_therapy , sep = \" & \" , remove = FALSE ) 1 ejercicio1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity treatment_urgency pathologic_stage histological_type number_of_lymph_ ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA & no NA infiltratinglobular ~ 4 2 50 0.6974 2 & yes 2 infiltratingductalc ~ 1 3 62 0.7666 2 & no 2 infiltratingductalc ~ 1 4 52 0.6869 1 & no 1 infiltratingductalc ~ 0 5 50 0.649 3 & no 3 infiltratinglobular ~ 4 6 42 0.6501 2 & yes 2 infiltratinglobular ~ 0 7 63 0.5553 4 & no 4 infiltratinglobular ~ 0 8 52 0.8368 2 & yes 2 other , specify NA 9 70 0.9328 1 & NA 1 other , specify 0 10 59 0.6906 2 & NA 2 infiltratingductalc ~ 0 # ... with 1,087 more rows, and 5 more variables: gender_and_race <chr>, radiation_therapy <chr>, # ethnicity <chr>, Median_overall_survival <chr>, overall_survival <chr>","title":"Combinar columnas"},{"location":"ordenar/#separar-columnas","text":"De la misma forma, podemos separar columnas f\u00e1cilmente empleando separate() : 1 separate ( < DATOS > , < NOMBRE_COLUMNA > , into = c ( \"<COL_NUEVA_1>\" , \"<COL_NUEVA_2>\" ), sep = \"<SEPARADOR>\" ) Esta funci\u00f3n es muy \u00fatil, pues permite separar las columnas empleando cualquier tipo de caracter como separador. Por ejemplo, en nuestro set de datos encontramos las variables \"g\u00e9nero\" y \"raza\" en una misma columna llamada gender_and_race . Vamos a separarlas: 1 ejemplo3 <- separate ( brca , gender_and_race , into = c ( \"gender\" , \"race\" ), sep = \"/\" ) 1 ejemplo3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 11 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender race < chr > < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 NA infiltratinglobular ~ 4 female white 2 50 0.6974 2 infiltratingductalc ~ 1 female blackoraf ~ 3 62 0.7666 2 infiltratingductalc ~ 1 female blackoraf ~ 4 52 0.6869 1 infiltratingductalc ~ 0 female blackoraf ~ 5 50 0.649 3 infiltratinglobular ~ 4 female white 6 42 0.6501 2 infiltratinglobular ~ 0 female white 7 63 0.5553 4 infiltratinglobular ~ 0 female white 8 52 0.8368 2 other , specify NA female blackoraf ~ 9 70 0.9328 1 other , specify 0 female white 10 59 0.6906 2 infiltratingductalc ~ 0 female white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr>","title":"Separar columnas"},{"location":"ordenar/#reordenar-columnas","text":"Normalmente las variables se organizan de forma que aquellas que son m\u00e1s importantes se encuentran m\u00e1s hacia la izquierda. Trabajando podemos estimar que alguna variable es la m\u00e1s importante en nuestro caso y queremos que sea la que ocupa la primera columna. Esto es muy sencillo de arreglar empleando la funci\u00f3n relocate() : 1 relocate ( < DATOS > , < VARIABLE > ) Por ejemplo, mirando nuestros datos ordenados estimamos que la variable \" histological_type \" es la m\u00e1s importante para nuestro estudio. La reordenamos de la siguiente forma: 1 ejemplo4 <- relocate ( brca , histological_type ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 histological_type years_to_birth Tumor_purity pathologic_stage number_of_lymph_ ~ gender_and_race < chr > < chr > < chr > < chr > < chr > < chr > 1 infiltratinglobula ~ 55 0.7886 NA 4 female / white 2 infiltratingductal ~ 50 0.6974 2 1 female / blackorafr ~ 3 infiltratingductal ~ 62 0.7666 2 1 female / blackorafr ~ 4 infiltratingductal ~ 52 0.6869 1 0 female / blackorafr ~ 5 infiltratinglobula ~ 50 0.649 3 4 female / white 6 infiltratinglobula ~ 42 0.6501 2 0 female / white 7 infiltratinglobula ~ 63 0.5553 4 0 female / white 8 other , specify 52 0.8368 2 NA female / blackorafr ~ 9 other , specify 70 0.9328 1 0 female / white 10 infiltratingductal ~ 59 0.6906 2 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <chr>, overall_survival <chr> Ejercicio Con esta funci\u00f3n podemos colocar las columnas en las posiciones que queramos, no solamente en la primera columna. Intenta mover la variable \" ethnicity \" a la 3\u00aa columna. Pista 1 Puedes usar alguno de estos dos comandos dentro de relocate() : .before = o .after = . Pista 2 Prueba a usar: 1 2 3 4 relocate ( < DATOS > , < VARIABLE > , .before = < VARIABLE_ANTES > , .after = < VARIABLE_DESPUES > ) Respuesta 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .before = pathologic_stage ) Tambi\u00e9n sirve: 1 2 3 ejercicio2 <- relocate ( brca , ethnicity , .after = Tumor_purity ) En ambos casos obtenemos: 1 ejercicio2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity ethnicity pathologic_stage histological_type number_of_lymph_n ~ < chr > < chr > < chr > < chr > < chr > < chr > 1 55 0.7886 nothispanicor ~ NA infiltratinglobularca ~ 4 2 50 0.6974 nothispanicor ~ 2 infiltratingductalcar ~ 1 3 62 0.7666 nothispanicor ~ 2 infiltratingductalcar ~ 1 4 52 0.6869 nothispanicor ~ 1 infiltratingductalcar ~ 0 5 50 0.649 nothispanicor ~ 3 infiltratinglobularca ~ 4 6 42 0.6501 hispanicorlat ~ 2 infiltratinglobularca ~ 0 7 63 0.5553 hispanicorlat ~ 4 infiltratinglobularca ~ 0 8 52 0.8368 nothispanicor ~ 2 other , specify NA 9 70 0.9328 nothispanicor ~ 1 other , specify 0 10 59 0.6906 nothispanicor ~ 2 infiltratingductalcar ~ 0 # ... with 1,087 more rows, and 4 more variables: gender_and_race <chr>, radiation_therapy <chr>, # Median_overall_survival <chr>, overall_survival <chr>","title":"Reordenar columnas"},{"location":"ordenar/#cambiar-tipo-de-datos","text":"Al importar los datos, transformarlos a tibble y modificarlos hemos cambiado su naturaleza (esto se ve debajo de los nombres de las columnas). Esto, a la hora de realizar c\u00e1lculos estadisticos, modificaciones m\u00e1s complejas y representaciones gr\u00e1ficas puede darnos problemas, por lo que es conveniente transormarlos al tipo de dato correspondiente. Nota Es necesario antes conocer qu\u00e9 significan cada una de las funciones de conversi\u00f3n de datos. A continuaci\u00f3n, se muestran las m\u00e1s comunes: FUNCIONES TIPO DE DATO <chr> Car\u00e1cter <num> Num\u00e9rico <int> Entero <lgl> L\u00f3gico <fct> Factor <dte> Fecha <dtm> Fecha y hora <dbl> Decimales Usemos de nuevo nuestros datos. Muchas de nuestras variables son num\u00e9ricas. Sin embargo, a todas se les ha asignado el tipo car\u00e1cter. Podemos arreglar esto empleando la funci\u00f3n convert() , perteneciente al paquete de datos hablar : 1 convert ( < DATOS > , < FUNCI\u00d3N_CONVERSI\u00d3N > ( < COLUMNAS > )) Vemos que muchas de las variables ( years_to_birth , number_of_lymph_nodes , Median_overall_survival y overall_survival ) son n\u00fameros enteros ( <int> ) pero est\u00e1n clasificados como car\u00e1cter ( <chr> ). Arreglamos esto de forma sencilla: 1 2 3 4 5 6 7 ejemplo4 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ) ) 1 ejemplo4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < chr > < chr > < chr > < int > < chr > 1 55 0.7886 NA infiltratinglobula ~ 4 female / white 2 50 0.6974 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.7666 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.6869 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.6501 2 infiltratinglobula ~ 0 female / white 7 63 0.5553 4 infiltratinglobula ~ 0 female / white 8 52 0.8368 2 other , specify NA female / blackorafr ~ 9 70 0.9328 1 other , specify 0 female / white 10 59 0.6906 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> Podemos aplicar varios tipos de datos a diferentes variables. Por ejemplo, la variable Tumor_purity es una variable decimal ( <dbl> ): 1 2 3 4 5 6 7 8 9 10 11 ejemplo5 <- convert ( brca , int ( years_to_birth , number_of_lymph_nodes , Median_overall_survival , overall_survival ), dbl ( Tumor_purity ) ) 1 ejemplo5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # A tibble: 1,097 x 10 years_to_birth Tumor_purity pathologic_stage histological_type number_of_lymph_ ~ gender_and_race < int > < dbl > < chr > < chr > < int > < chr > 1 55 0.789 NA infiltratinglobula ~ 4 female / white 2 50 0.697 2 infiltratingductal ~ 1 female / blackorafr ~ 3 62 0.767 2 infiltratingductal ~ 1 female / blackorafr ~ 4 52 0.687 1 infiltratingductal ~ 0 female / blackorafr ~ 5 50 0.649 3 infiltratinglobula ~ 4 female / white 6 42 0.650 2 infiltratinglobula ~ 0 female / white 7 63 0.555 4 infiltratinglobula ~ 0 female / white 8 52 0.837 2 other , specify NA female / blackorafr ~ 9 70 0.933 1 other , specify 0 female / white 10 59 0.691 2 infiltratingductal ~ 0 female / white # ... with 1,087 more rows, and 4 more variables: radiation_therapy <chr>, ethnicity <chr>, # Median_overall_survival <int>, overall_survival <int> De esta forma hemos solucionado muchos problemas en el futuro por trabajar con datos err\u00f3neamentes clasificados.","title":"Cambiar tipo de datos"},{"location":"ordenar/#ejercicios-de-repaso","text":"Para ver si has entendido todo, intenta realizar los ejercicios propuestos en este enlace . Nota Cosulta el apartado \" Realizaci\u00f3n de ejercicios \" para saber como descargar, instalar y completar esta tarea.","title":"Ejercicios de repaso"},{"location":"ordenar/#referencias","text":"Referencias Tutorial de programaci\u00f3n en R orientado al estudiante de Bioqu\u00edmica ; Ismael S\u00e1nchez Pareja Suppl. Ch. 2: Import and Tidy Data ; Gabriel Odom Data import: cheat sheet ; Garrett Grolemund A grammer for data type conversion ; David Sjoberg Change column order: relocate LinkedOmics Data Download","title":"Referencias"},{"location":"tidyverse/","text":"Introducci\u00f3n a Tidyverse Uno de los principales problemas que va a encontrarse el bioqu\u00edmico en su \u00e1mbito laboral empieza a la hora de abordar enormes cantidades de datos obtenidos tras un an\u00e1lisis o captura de datos. A partir de estos datos sin procesar, muy dif\u00edcilmente se puede asimilar cu\u00e1l ha sido el resultado de este estudio, ya ni hablemos de llegar a cualquier tipo de conclusi\u00f3n. Para poder utilizar estos datos, es necesario digerirlos , es decir, debemos ordenarlos, organizarlos, realizar las transformaciones necesarias y representarlos de alguna manera, de forma que seamos capaces de interpretarlos. La disciplina encargada de transformar estos datos \"crudos\" indescifrables en conocimiento aplicable se denomina ciencia de datos , con la que se es capaz de generar muchas posibles hip\u00f3tesis que explorar en profundidad. Existen numerosas herramientas inform\u00e1ticas (tales como software, paquetes de funciones, etc.) a disposici\u00f3n del investigador para llevar a cabo esta tarea. En un principio, para un bioqu\u00edmico con poca experiencia en el an\u00e1lisis inform\u00e1tico de datos, es complicado saber por cu\u00e1l de estas herramientas empezar. La ciencia de datos es una disciplina extens\u00edsima, y no existe una sola forma \"correcta\" de entrar en este mundo. En este tutorial vamos a introducir al alumno en esta materia con Tidyverse . \u00bfQu\u00e9 es Tidyverse? Tidyverse es una colecci\u00f3n de paquetes de R , de c\u00f3digo abierto, dise\u00f1ados para su aplicaci\u00f3n en la ciencia de datos . Estos paquetes y sus funciones son los mostrados a continuaci\u00f3n: PAQUETE DESCRIPCI\u00d3N readr Facilita la importaci\u00f3n de datos tibble Crea variaciones de los data frames est\u00e1ndar de R tidyr Contiene funciones para el reordenamiento de datos dplyr Contiene funciones para modificar data frames purrr Programaci\u00f3n funcional de datos ggplot2 Visualizaci\u00f3n de datos Veremos la funci\u00f3n de cada uno de estos paquetes en profundidad a lo largo de este tutorial. El flujo de trabajo en la ciencia de datos El flujo de trabajo normal durante el manejo de datos puede seguir el siguiente esquema: En primer lugar, debes importar tus datos a R. Una vez dentro, debes ordenarlos de forma consistente (suele ser una buena referencia inicial tener una variable por columna y una observaci\u00f3n por fila ), permiti\u00e9ndote empezar a encontrar relaciones. Los datos ordenados todav\u00eda no muestran f\u00e1cilmente toda la informaci\u00f3n que contienen. Primero es necesario entender su contexto. Para ello, debemos seguir un proceso de transformaci\u00f3n, visualizaci\u00f3n y modelado. Transformar permite centrarnos en nuestras variables de inter\u00e9s y crear otras nuevas. Visualizar significa \"ver\" los resultados de forma m\u00e1s clara y natural, pudiendo encontrar respuestas a nuestras preguntas o resultados inesperados que nos hagan formular nuevas cuestiones. Modelar es buscar una interpretaci\u00f3n matem\u00e1tica o computacional que expliquen los resultados obtenidos, de forma que podamos obtener nuevas referencias y suposiciones, de forma que podamos retomar los datos desde otra perspectiva y resolver el problema. Finalmente, tras obtener los resultados finales, comunicamos los resultados. Adem\u00e1s, rodeando todos estos procesos encontramos la programaci\u00f3n , que es la herramienta que empleamos durante todo el proyecto. Requisitos previos Para empezar a utilizar Tidyverse, es necesario tener instalado R y RStudio (puedes encontrar ayuda sobre c\u00f3mo instalar y manejar RStudio clickando aqu\u00ed ). Una vez instalados, ejecutamos el siguiente comando en la consola de RStudio: 1 install.packages ( \"tidyverse\" ) Ahora tendremos el paquete instalado y listo para usar. Para activarlo, ejecutamos el comando a continuaci\u00f3n: 1 library ( \"tidyverse\" ) Tras esto, Tidyverse est\u00e1 listo para usarse. Es importante ejecutar este \u00faltimo comando al inicio de una nueva sesi\u00f3n. Referencias Referencias Tidyverse; R packages for data science ; Hadley Wickham, Garrett Grolemund et al. R for Data Science ; Hadley Wickham, Garrett Grolemund et al.","title":"Tidyverse"},{"location":"tidyverse/#introduccion-a-tidyverse","text":"Uno de los principales problemas que va a encontrarse el bioqu\u00edmico en su \u00e1mbito laboral empieza a la hora de abordar enormes cantidades de datos obtenidos tras un an\u00e1lisis o captura de datos. A partir de estos datos sin procesar, muy dif\u00edcilmente se puede asimilar cu\u00e1l ha sido el resultado de este estudio, ya ni hablemos de llegar a cualquier tipo de conclusi\u00f3n. Para poder utilizar estos datos, es necesario digerirlos , es decir, debemos ordenarlos, organizarlos, realizar las transformaciones necesarias y representarlos de alguna manera, de forma que seamos capaces de interpretarlos. La disciplina encargada de transformar estos datos \"crudos\" indescifrables en conocimiento aplicable se denomina ciencia de datos , con la que se es capaz de generar muchas posibles hip\u00f3tesis que explorar en profundidad. Existen numerosas herramientas inform\u00e1ticas (tales como software, paquetes de funciones, etc.) a disposici\u00f3n del investigador para llevar a cabo esta tarea. En un principio, para un bioqu\u00edmico con poca experiencia en el an\u00e1lisis inform\u00e1tico de datos, es complicado saber por cu\u00e1l de estas herramientas empezar. La ciencia de datos es una disciplina extens\u00edsima, y no existe una sola forma \"correcta\" de entrar en este mundo. En este tutorial vamos a introducir al alumno en esta materia con Tidyverse .","title":"Introducci\u00f3n a Tidyverse"},{"location":"tidyverse/#que-es-tidyverse","text":"Tidyverse es una colecci\u00f3n de paquetes de R , de c\u00f3digo abierto, dise\u00f1ados para su aplicaci\u00f3n en la ciencia de datos . Estos paquetes y sus funciones son los mostrados a continuaci\u00f3n: PAQUETE DESCRIPCI\u00d3N readr Facilita la importaci\u00f3n de datos tibble Crea variaciones de los data frames est\u00e1ndar de R tidyr Contiene funciones para el reordenamiento de datos dplyr Contiene funciones para modificar data frames purrr Programaci\u00f3n funcional de datos ggplot2 Visualizaci\u00f3n de datos Veremos la funci\u00f3n de cada uno de estos paquetes en profundidad a lo largo de este tutorial.","title":"\u00bfQu\u00e9 es Tidyverse?"},{"location":"tidyverse/#el-flujo-de-trabajo-en-la-ciencia-de-datos","text":"El flujo de trabajo normal durante el manejo de datos puede seguir el siguiente esquema: En primer lugar, debes importar tus datos a R. Una vez dentro, debes ordenarlos de forma consistente (suele ser una buena referencia inicial tener una variable por columna y una observaci\u00f3n por fila ), permiti\u00e9ndote empezar a encontrar relaciones. Los datos ordenados todav\u00eda no muestran f\u00e1cilmente toda la informaci\u00f3n que contienen. Primero es necesario entender su contexto. Para ello, debemos seguir un proceso de transformaci\u00f3n, visualizaci\u00f3n y modelado. Transformar permite centrarnos en nuestras variables de inter\u00e9s y crear otras nuevas. Visualizar significa \"ver\" los resultados de forma m\u00e1s clara y natural, pudiendo encontrar respuestas a nuestras preguntas o resultados inesperados que nos hagan formular nuevas cuestiones. Modelar es buscar una interpretaci\u00f3n matem\u00e1tica o computacional que expliquen los resultados obtenidos, de forma que podamos obtener nuevas referencias y suposiciones, de forma que podamos retomar los datos desde otra perspectiva y resolver el problema. Finalmente, tras obtener los resultados finales, comunicamos los resultados. Adem\u00e1s, rodeando todos estos procesos encontramos la programaci\u00f3n , que es la herramienta que empleamos durante todo el proyecto.","title":"El flujo de trabajo en la ciencia de datos"},{"location":"tidyverse/#requisitos-previos","text":"Para empezar a utilizar Tidyverse, es necesario tener instalado R y RStudio (puedes encontrar ayuda sobre c\u00f3mo instalar y manejar RStudio clickando aqu\u00ed ). Una vez instalados, ejecutamos el siguiente comando en la consola de RStudio: 1 install.packages ( \"tidyverse\" ) Ahora tendremos el paquete instalado y listo para usar. Para activarlo, ejecutamos el comando a continuaci\u00f3n: 1 library ( \"tidyverse\" ) Tras esto, Tidyverse est\u00e1 listo para usarse. Es importante ejecutar este \u00faltimo comando al inicio de una nueva sesi\u00f3n.","title":"Requisitos previos"},{"location":"tidyverse/#referencias","text":"Referencias Tidyverse; R packages for data science ; Hadley Wickham, Garrett Grolemund et al. R for Data Science ; Hadley Wickham, Garrett Grolemund et al.","title":"Referencias"},{"location":"visualizar/","text":"Visualizaci\u00f3n de datos Introducci\u00f3n Es innegable que la ciencias de datos, sobre todo para los reci\u00e9n llegados, puede resultar un poco tediosa. Podemos deducir del esquema del apartado anterior que, a la hora de entrar en la ciencia de datos, lo mejor es empezar por el principio, es decir, importar, ordenar y transformar los datos. Sin embargo, esta tarea puede ser muy aburrida y frustrante. Tidyverse, por tanto, propone comenzar el estudio de esta disciplina por la parte de visualizaci\u00f3n de datos que ya han sido ordenados y transformados, tarea mucho m\u00e1s amigable para los nuevos. El paquete de Tidyverse encargado de la generaci\u00f3n de gr\u00e1ficas es ggplot2 . Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse ) En la consola veremos el siguiente mensaje: 1 2 3 4 5 6 7 8 #> \u2500\u2500 Attaching packages \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse 1.3.0 \u2500\u2500 #> \u2714 ggplot2 3.3.2 \u2714 purrr 0.3.4 #> \u2714 tibble 3.0.3 \u2714 dplyr 1.0.2 #> \u2714 tidyr 1.1.2 \u2714 stringr 1.4.0 #> \u2714 readr 1.4.0 \u2714 forcats 0.5.0 #> \u2500\u2500 Conflicts \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse_conflicts() \u2500\u2500 #> \u2716 dplyr::filter() masks stats::filter() #> \u2716 dplyr::lag() masks stats::lag() ggplot2 est\u00e1 activo y listo para usarse. Activaremos Tidyverse cada vez que iniciemos una nueva sesi\u00f3n en RStudio. Podemos ver, adem\u00e1s, como hay algunos paquetes en conflicto con otras funciones de R base, pero eso no importa demasiado por ahora. Comencemos a graficar con ggplot2 . Como todav\u00eda no sabemos importar nuestros propios datos a Tidyverse, vamos a usar una serie de conjuntos de datos incluidos de serie en este paquete, con los que podemos practicar. Podemos ver uno de ellos con el comando mpg : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > mpg # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class <chr> <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2 2008 4 auto(av) f 21 30 p compact 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact # ... with 224 more rows Razona: \u00bfC\u00f3mo podr\u00edas mostrar las 20 primeras filas de este conjunto? 1\u00aa Pista Tienes que utilizar print() . Puedes averiguar como usarlo escribiendo el comando ?print . 2\u00aa Pista Utiliza el argumento n = <N\u00daMERO> dentro del comando anterior. Respuesta Empleamos el siguiente comando: 1 > print ( mpg , n = 20 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class <chr> <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2 2008 4 auto(av) f 21 30 p compact 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact 11 audi a4 quattro 2 2008 4 auto(s6) 4 19 27 p compact 12 audi a4 quattro 2.8 1999 6 auto(l5) 4 15 25 p compact 13 audi a4 quattro 2.8 1999 6 manual(m5) 4 17 25 p compact 14 audi a4 quattro 3.1 2008 6 auto(s6) 4 17 25 p compact 15 audi a4 quattro 3.1 2008 6 manual(m6) 4 15 25 p compact 16 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize 17 audi a6 quattro 3.1 2008 6 auto(s6) 4 17 25 p midsize 18 audi a6 quattro 4.2 2008 8 auto(s6) 4 16 23 p midsize 19 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 20 r suv 20 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 15 e suv # ... with 214 more rows mpg es un conjunto de datos que re\u00fane informaci\u00f3n sobre el consumo de combustible de diferentes veh\u00edculos, cuyas variables son las siguientes: VARIABLE DESCRIPCI\u00d3N manufacturer Nombre de la empresa fabricante model Modelo espec\u00edfico del veh\u00edculo displ Cilindrada (en litros) year A\u00f1o de fabricaci\u00f3n cyl N\u00famero de cilindros trans Tipo de transmisi\u00f3n (manual o autom\u00e1tica) drv Tipo de tren de transmisi\u00f3n (frontal, trasera o 4x4) cty Gasto en ciudad (millas por gal\u00f3n) hwy Gasto en carretera (millas por gal\u00f3n) fl Tipo de combustible class Tipo de coche Conociendo qu\u00e9 representa cada variable, podemos empezar a representarla gr\u00e1ficamente de forma l\u00f3gica. El esquema que vamos a seguir para ello es el siguiente: 1 2 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) Empezamos con la funci\u00f3n ggplot() , que crea el sistema de coordenadas en el que se representan los datos. Dentro de esta funci\u00f3n debemos incluir el conjunto de datos al que pertenecen las variables que queremos representar (en este caso, data = mpg ). Importante: En ggplot2 , para continuar con el comando en la siguente linea, es necesario colocar un s\u00edmbolo \"+\" al final de la anterior. Como todav\u00eda no hemos elegido las variables, la gr\u00e1fica sigue en blanco. Para seleccionarlas, primero debemos elegir el tipo de gr\u00e1fico que queremos crear, dependiendo este del tipo de variable que queramos representar (si son continuas o discontinuas). Los diferentes tipos de gr\u00e1ficos los iremos viendo conforme avanzamos en el tutorial. Algunos de estos son: TIPO DE GR\u00c1FICA DESCRIPCI\u00d3N geom_point Diagrama de dispersi\u00f3n geom_smooth Gr\u00e1fico de linea suavizada geom_bar Diagrama de barras (proporcional) geom_col Diagrama de barras (valores totales) geom_boxplot Diagrama de cajas Por ahora, vamos a utilizar geom_point , que genera un diagrama de dispersi\u00f3n. Finalmente, tenemos que elegir qu\u00e9 vamos a mostrar. Para ello, debemos emplear la funci\u00f3n mapping , que define las variables a representar. Esta debe ir acompa\u00f1ada del argumento aes() , junto con x e y (en nuestro caso, x = displ e y = hwy ). Veamos c\u00f3mo quedar\u00eda este ejemplo. 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) Obtenemos una gr\u00e1fica como esta: Razona: Prueba a hacer lo mismo, pero representando el gasto en carretera vs. el gasto en ciudad. \u00bfQu\u00e9 observas? Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = hwy , y = cty )) El gasto de combustible, tanto en carretera como en ciudad, sigue una clara tendencia lineal. Aesthetics El comando aes() , adem\u00e1s de para introducir las variables principales (x e y), sirve para introducir otras variables y modificar de qu\u00e9 forma se van a ver en la gr\u00e1fica. Ilustr\u00e1ndonos con el ejemplo anterior, podemos ver c\u00f3mo la gr\u00e1fica nos muestra la relaci\u00f3n que existe entre el consumo de un determinado veh\u00edculo y su cilindrada. Si quisi\u00e9ramos observar la relaci\u00f3n que tienen estos resultados con la variable class (el tipo de coche), podemos introducirla dentro del comando aes() como propiedad visual. Representamos la clase de coche dentro de la gr\u00e1fica anterior cambiando el color de los puntos de la siguiente forma: 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) Como vemos, adem\u00e1s de representar el gasto en carretera con respecto a la cilindrada, vemos con cada color cada tipo de coche que hay, revelando informaci\u00f3n extra. Razona: Observando el ejemplo anterior, \u00bfa qu\u00e9 conclusion puedes llegar en relaci\u00f3n al tipo de veh\u00edculo, su gasto en carretera y su cilindrada? Respuesta: Los coches, por norma general, gastan m\u00e1s en carretera conforme aumenta su cilindrada. Sin embargo, en este ejemplo existe un grupo de coches que no sigue esta suposici\u00f3n. Al observar la variable que determina el tipo de coche en la gr\u00e1fica, vemos como estos veh\u00edculos son de dos asientos, que, al pesar menos, gastan menos combustible que los dem\u00e1s, independientemente del tama\u00f1o del motor. Podemos mapear cualquier variable dentro del gr\u00e1fico incluy\u00e9ndola en aes() . Adem\u00e1s, podemos elegir que propiedad visual asignar a esta (color, tama\u00f1o de los puntos...). Podemos representar el tipo de vehiculos cambiando el tama\u00f1o de los puntos (con size ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , size = class )) Tambien podemos cambiar su transparencia (con alpha ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , alpha = class )) E incluso la forma de los puntos (con shape ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , shape = class )) Estos ejemplos, sin embargo, muestran una serie de problemas. En los dos primeros se dificulta la visi\u00f3n de algunos puntos, mientras que en el tercero ggplot2 \u00fanicamente representa seis formas de puntos, que son f\u00e1cilmente diferenciables entre s\u00ed. Cuando el n\u00famero de valores es mayor a seis, se dejan de representar algunas de estos. Estos aesthetics , por tanto, solo se emplean en casos muy espec\u00edficos. Razona: Sobre los ejemplos anteriores, \u00bfc\u00f3mo podr\u00edas dise\u00f1ar otras gr\u00e1ficas empleando diferentes aesthetics ? Pista: Puedes mirar todos los aesthetics posibles para el diagrama de dispersi\u00f3n usando ?geom_point . Una cosa muy importante a tener en cuenta es que aes() solo sirve para modificar las gr\u00e1ficas con respecto a una variable. Tambi\u00e9n podemos modificarla sin tener en cuenta los valores. Por ejemplo, podemos cambiar el color de todos los puntos sacando color del comando aes() : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy ), color = \"blue\" ) Si introduj\u00e9semos color = \"blue\" dentro de aes() se muestra una gr\u00e1fica sin sentido, pues ggplot2 interpreta que no existe ninguna variable llamada blue : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = \"blue\" )) Dise\u00f1a un diagrama de dispersi\u00f3n que represente la cilindrada vs. el gasto en ciudad Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty )) Sobre la gr\u00e1fica del ejercicio anterior, cambia la forma de los puntos por cuadrados ( shape = 15 ) y representa el tipo de combustible seg\u00fan el color. Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = fl ), shape = 15 ) En el ejemplo anterior, \u00bfc\u00f3mo modificar\u00edas la gr\u00e1fica de forma que represente aquellos vehiculos con una cilindrada menor que 5 de un color y aquellos con cilindrada mayor de otro? Pista: Prueba a usar color = displ < 5 . Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = displ < 5 )) Gr\u00e1ficos estad\u00edsticos Son gr\u00e1ficos estad\u00edsticos aquellos que representan datos cuantitativos. Entre ellos encontramos los gr\u00e1ficos de dispersi\u00f3n (ya estudiados), diagramas de barras, diagramas de cajas, histogramas, etc. Para estudiar estos gr\u00e1ficos vamos a usar un nuevo conjunto de datos denominado \" diamonds \", incluido en ggplot2 , que contiene caracter\u00edsticas estudiadas sobre un gran n\u00famero de diamantes. Nota Puedes encontrar toda la informaci\u00f3n sobre este dataset (variables, descripciones, etc.) empleando el comando ?diamonds . Empecemos estudiando los gr\u00e1ficos de barras . Para ello, usamos el comando geom_bar() , de la misma forma que con los gr\u00e1ficos de dispersi\u00f3n. Imaginemos que queremos clasificar los diamantes seg\u00fan la calidad del corte (variable cut ). Para ello, usamos: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut )) ggplot2 interpreta autom\u00e1ticamente que, al no concretar la variable y , debe representar el n\u00famero total de diamantes por calidad de corte. Para ello, ggplot2 emplea unas transformaciones estadisticas capaces de crear nuevas variables modificando las ya existentes. En este caso, lo que hace es contar el n\u00famero de diamantes dentro de cada tipo de corte. Nota Si quieres saber m\u00e1s sobre estas transformaciones estad\u00edsticas, puedes encontrar m\u00e1s informaci\u00f3n aqu\u00ed . Al igual que el resto de gr\u00e1ficas, empleando aes() puedes modificar a apariencia del gr\u00e1fico de barras: color cambia el color del borde de las barras fill cambia el color del relleno Por ejemplo, podemos representar la claridad de los diamantes (variable ```clarity````) de la siguiente forma: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut , fill = clarity )) Tambi\u00e9n podemos representar diagramas de cajas , empleando la funci\u00f3n geom_box . Como ejemplo, podemos representar el gasto en carretera seg\u00fan el tipo de coche de la siguiente manera: 1 2 ggplot ( data = mpg , mapping = aes ( x = class , y = hwy )) + geom_boxplot () Si necesitamos girar la gr\u00e1fica, simplemente a\u00f1adimos coord_flip() justo a continuaci\u00f3n de nuestra gr\u00e1fica: 1 2 3 ggplot ( data = mpg , mapping = aes ( x = class , y = hwy )) + geom_boxplot () + coord_flip () Razona: \u00bfA qu\u00e9 conclusi\u00f3n puedes llegar observando el ejemplo anterior? Gr\u00e1ficas m\u00faltiples A veces, para facilitar la visualizaci\u00f3n de los datos, se intentan representar varias gr\u00e1ficas a la vez. Para ello, existen dos formas: Representar muchas variables dentro de una misma gr\u00e1fica ( por capas ). Dividir los datos en varias ventanas ( facets ). Gr\u00e1ficas por capas ggplot2 permite representar muchas variables en una misma gr\u00e1fica de forma sencilla. Supongamos que necesitamos representar una linea de tendencia del gasto en carretera con respecto a la cilindrada. Usando geom_smooth() dibujamos una linea de tendencia suavizada del conjuto de datos propuesto: 1 2 ggplot ( data = mpg ) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Nota Al igual que con el resto de funciones geom , geom_smooth() tambi\u00e9n posee sus aesthetics espec\u00edficos (tipo, grosor, color de linea...). Puedes usar ?geom_smooth para ver los que hay disponibles. Si quisieramos representar esta linea como una capa sobre un diagrama de dispersi\u00f3n, simplemente escribimos sus respectivas funciones geom una despu\u00e9s de la otra: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Podemos combinar tantas capas como queramos, siempre y cuando no existan incoherencias entre las variables representadas. Gr\u00e1ficas por ventanas ( facets ) Imaginemos que queremos representar el gasto en carretera con respecto a la cilindrada. Imaginemos tambi\u00e9n que queremos representar los tipos de veh\u00edculos. Podemos hacer como hicimos antes, es decir, representar por colores. Esto, sin embargo, a veces puede resultar en gr\u00e1ficas dif\u00edciles de observar, pues es complicado distinguir los diferentes valores. Para solucionar esto, podemos representar muchas gr\u00e1ficas a la vez, dividiendo las variables en numerosas ventanas. Para ello, usamos facet_wrap() . Se usa de la siguiente forma: 1 2 3 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) + facet_wrap ( ~ < VARIABLE > , nrow = < N\u00daMERO DE FILAS > ) Representamos el ejemplo anterior: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_wrap ( ~ class , nrow = 2 ) Con facets podemos representar dos variables, empleando la funci\u00f3n facet_grid() . Por ejemplo, usemos como variables el tipo de tren de transmision y el n\u00famero de cilindros: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_grid ( drv ~ cyl ) Los facets son muy \u00fatiles cuando queremos ver una visi\u00f3n global de todas las posibles representaciones que podemos hacer. Con ella, vemos multitud de gr\u00e1ficas a la vez y podemos seleccionar la que m\u00e1s nos interese. Ejercicios de repaso Para ver si has entendido todo, intenta realizar los ejercicios propuestos en este enlace . Nota Cosulta el apartado \" Realizaci\u00f3n de ejercicios \" para saber c\u00f3mo descargar, instalar y completar esta tarea. Referencias Referencias R for Data Science ; Hadley Wickham, Garrett Grolemund et al.","title":"Visualizar datos"},{"location":"visualizar/#visualizacion-de-datos","text":"","title":"Visualizaci\u00f3n de datos"},{"location":"visualizar/#introduccion","text":"Es innegable que la ciencias de datos, sobre todo para los reci\u00e9n llegados, puede resultar un poco tediosa. Podemos deducir del esquema del apartado anterior que, a la hora de entrar en la ciencia de datos, lo mejor es empezar por el principio, es decir, importar, ordenar y transformar los datos. Sin embargo, esta tarea puede ser muy aburrida y frustrante. Tidyverse, por tanto, propone comenzar el estudio de esta disciplina por la parte de visualizaci\u00f3n de datos que ya han sido ordenados y transformados, tarea mucho m\u00e1s amigable para los nuevos. El paquete de Tidyverse encargado de la generaci\u00f3n de gr\u00e1ficas es ggplot2 . Abrimos RStudio y activamos la librer\u00eda: 1 library ( tidyverse ) En la consola veremos el siguiente mensaje: 1 2 3 4 5 6 7 8 #> \u2500\u2500 Attaching packages \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse 1.3.0 \u2500\u2500 #> \u2714 ggplot2 3.3.2 \u2714 purrr 0.3.4 #> \u2714 tibble 3.0.3 \u2714 dplyr 1.0.2 #> \u2714 tidyr 1.1.2 \u2714 stringr 1.4.0 #> \u2714 readr 1.4.0 \u2714 forcats 0.5.0 #> \u2500\u2500 Conflicts \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 tidyverse_conflicts() \u2500\u2500 #> \u2716 dplyr::filter() masks stats::filter() #> \u2716 dplyr::lag() masks stats::lag() ggplot2 est\u00e1 activo y listo para usarse. Activaremos Tidyverse cada vez que iniciemos una nueva sesi\u00f3n en RStudio. Podemos ver, adem\u00e1s, como hay algunos paquetes en conflicto con otras funciones de R base, pero eso no importa demasiado por ahora. Comencemos a graficar con ggplot2 . Como todav\u00eda no sabemos importar nuestros propios datos a Tidyverse, vamos a usar una serie de conjuntos de datos incluidos de serie en este paquete, con los que podemos practicar. Podemos ver uno de ellos con el comando mpg : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > mpg # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class <chr> <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2 2008 4 auto(av) f 21 30 p compact 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact # ... with 224 more rows Razona: \u00bfC\u00f3mo podr\u00edas mostrar las 20 primeras filas de este conjunto? 1\u00aa Pista Tienes que utilizar print() . Puedes averiguar como usarlo escribiendo el comando ?print . 2\u00aa Pista Utiliza el argumento n = <N\u00daMERO> dentro del comando anterior. Respuesta Empleamos el siguiente comando: 1 > print ( mpg , n = 20 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class <chr> <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compact 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2 2008 4 auto(av) f 21 30 p compact 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compact 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compact 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compact 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact 11 audi a4 quattro 2 2008 4 auto(s6) 4 19 27 p compact 12 audi a4 quattro 2.8 1999 6 auto(l5) 4 15 25 p compact 13 audi a4 quattro 2.8 1999 6 manual(m5) 4 17 25 p compact 14 audi a4 quattro 3.1 2008 6 auto(s6) 4 17 25 p compact 15 audi a4 quattro 3.1 2008 6 manual(m6) 4 15 25 p compact 16 audi a6 quattro 2.8 1999 6 auto(l5) 4 15 24 p midsize 17 audi a6 quattro 3.1 2008 6 auto(s6) 4 17 25 p midsize 18 audi a6 quattro 4.2 2008 8 auto(s6) 4 16 23 p midsize 19 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 14 20 r suv 20 chevrolet c1500 suburban 2wd 5.3 2008 8 auto(l4) r 11 15 e suv # ... with 214 more rows mpg es un conjunto de datos que re\u00fane informaci\u00f3n sobre el consumo de combustible de diferentes veh\u00edculos, cuyas variables son las siguientes: VARIABLE DESCRIPCI\u00d3N manufacturer Nombre de la empresa fabricante model Modelo espec\u00edfico del veh\u00edculo displ Cilindrada (en litros) year A\u00f1o de fabricaci\u00f3n cyl N\u00famero de cilindros trans Tipo de transmisi\u00f3n (manual o autom\u00e1tica) drv Tipo de tren de transmisi\u00f3n (frontal, trasera o 4x4) cty Gasto en ciudad (millas por gal\u00f3n) hwy Gasto en carretera (millas por gal\u00f3n) fl Tipo de combustible class Tipo de coche Conociendo qu\u00e9 representa cada variable, podemos empezar a representarla gr\u00e1ficamente de forma l\u00f3gica. El esquema que vamos a seguir para ello es el siguiente: 1 2 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) Empezamos con la funci\u00f3n ggplot() , que crea el sistema de coordenadas en el que se representan los datos. Dentro de esta funci\u00f3n debemos incluir el conjunto de datos al que pertenecen las variables que queremos representar (en este caso, data = mpg ). Importante: En ggplot2 , para continuar con el comando en la siguente linea, es necesario colocar un s\u00edmbolo \"+\" al final de la anterior. Como todav\u00eda no hemos elegido las variables, la gr\u00e1fica sigue en blanco. Para seleccionarlas, primero debemos elegir el tipo de gr\u00e1fico que queremos crear, dependiendo este del tipo de variable que queramos representar (si son continuas o discontinuas). Los diferentes tipos de gr\u00e1ficos los iremos viendo conforme avanzamos en el tutorial. Algunos de estos son: TIPO DE GR\u00c1FICA DESCRIPCI\u00d3N geom_point Diagrama de dispersi\u00f3n geom_smooth Gr\u00e1fico de linea suavizada geom_bar Diagrama de barras (proporcional) geom_col Diagrama de barras (valores totales) geom_boxplot Diagrama de cajas Por ahora, vamos a utilizar geom_point , que genera un diagrama de dispersi\u00f3n. Finalmente, tenemos que elegir qu\u00e9 vamos a mostrar. Para ello, debemos emplear la funci\u00f3n mapping , que define las variables a representar. Esta debe ir acompa\u00f1ada del argumento aes() , junto con x e y (en nuestro caso, x = displ e y = hwy ). Veamos c\u00f3mo quedar\u00eda este ejemplo. 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) Obtenemos una gr\u00e1fica como esta: Razona: Prueba a hacer lo mismo, pero representando el gasto en carretera vs. el gasto en ciudad. \u00bfQu\u00e9 observas? Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = hwy , y = cty )) El gasto de combustible, tanto en carretera como en ciudad, sigue una clara tendencia lineal.","title":"Introducci\u00f3n"},{"location":"visualizar/#aesthetics","text":"El comando aes() , adem\u00e1s de para introducir las variables principales (x e y), sirve para introducir otras variables y modificar de qu\u00e9 forma se van a ver en la gr\u00e1fica. Ilustr\u00e1ndonos con el ejemplo anterior, podemos ver c\u00f3mo la gr\u00e1fica nos muestra la relaci\u00f3n que existe entre el consumo de un determinado veh\u00edculo y su cilindrada. Si quisi\u00e9ramos observar la relaci\u00f3n que tienen estos resultados con la variable class (el tipo de coche), podemos introducirla dentro del comando aes() como propiedad visual. Representamos la clase de coche dentro de la gr\u00e1fica anterior cambiando el color de los puntos de la siguiente forma: 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) Como vemos, adem\u00e1s de representar el gasto en carretera con respecto a la cilindrada, vemos con cada color cada tipo de coche que hay, revelando informaci\u00f3n extra. Razona: Observando el ejemplo anterior, \u00bfa qu\u00e9 conclusion puedes llegar en relaci\u00f3n al tipo de veh\u00edculo, su gasto en carretera y su cilindrada? Respuesta: Los coches, por norma general, gastan m\u00e1s en carretera conforme aumenta su cilindrada. Sin embargo, en este ejemplo existe un grupo de coches que no sigue esta suposici\u00f3n. Al observar la variable que determina el tipo de coche en la gr\u00e1fica, vemos como estos veh\u00edculos son de dos asientos, que, al pesar menos, gastan menos combustible que los dem\u00e1s, independientemente del tama\u00f1o del motor. Podemos mapear cualquier variable dentro del gr\u00e1fico incluy\u00e9ndola en aes() . Adem\u00e1s, podemos elegir que propiedad visual asignar a esta (color, tama\u00f1o de los puntos...). Podemos representar el tipo de vehiculos cambiando el tama\u00f1o de los puntos (con size ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , size = class )) Tambien podemos cambiar su transparencia (con alpha ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , alpha = class )) E incluso la forma de los puntos (con shape ): 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , shape = class )) Estos ejemplos, sin embargo, muestran una serie de problemas. En los dos primeros se dificulta la visi\u00f3n de algunos puntos, mientras que en el tercero ggplot2 \u00fanicamente representa seis formas de puntos, que son f\u00e1cilmente diferenciables entre s\u00ed. Cuando el n\u00famero de valores es mayor a seis, se dejan de representar algunas de estos. Estos aesthetics , por tanto, solo se emplean en casos muy espec\u00edficos. Razona: Sobre los ejemplos anteriores, \u00bfc\u00f3mo podr\u00edas dise\u00f1ar otras gr\u00e1ficas empleando diferentes aesthetics ? Pista: Puedes mirar todos los aesthetics posibles para el diagrama de dispersi\u00f3n usando ?geom_point . Una cosa muy importante a tener en cuenta es que aes() solo sirve para modificar las gr\u00e1ficas con respecto a una variable. Tambi\u00e9n podemos modificarla sin tener en cuenta los valores. Por ejemplo, podemos cambiar el color de todos los puntos sacando color del comando aes() : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy ), color = \"blue\" ) Si introduj\u00e9semos color = \"blue\" dentro de aes() se muestra una gr\u00e1fica sin sentido, pues ggplot2 interpreta que no existe ninguna variable llamada blue : 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = \"blue\" )) Dise\u00f1a un diagrama de dispersi\u00f3n que represente la cilindrada vs. el gasto en ciudad Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty )) Sobre la gr\u00e1fica del ejercicio anterior, cambia la forma de los puntos por cuadrados ( shape = 15 ) y representa el tipo de combustible seg\u00fan el color. Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = fl ), shape = 15 ) En el ejemplo anterior, \u00bfc\u00f3mo modificar\u00edas la gr\u00e1fica de forma que represente aquellos vehiculos con una cilindrada menor que 5 de un color y aquellos con cilindrada mayor de otro? Pista: Prueba a usar color = displ < 5 . Respuesta 1 2 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = cty , color = displ < 5 ))","title":"Aesthetics"},{"location":"visualizar/#graficos-estadisticos","text":"Son gr\u00e1ficos estad\u00edsticos aquellos que representan datos cuantitativos. Entre ellos encontramos los gr\u00e1ficos de dispersi\u00f3n (ya estudiados), diagramas de barras, diagramas de cajas, histogramas, etc. Para estudiar estos gr\u00e1ficos vamos a usar un nuevo conjunto de datos denominado \" diamonds \", incluido en ggplot2 , que contiene caracter\u00edsticas estudiadas sobre un gran n\u00famero de diamantes. Nota Puedes encontrar toda la informaci\u00f3n sobre este dataset (variables, descripciones, etc.) empleando el comando ?diamonds . Empecemos estudiando los gr\u00e1ficos de barras . Para ello, usamos el comando geom_bar() , de la misma forma que con los gr\u00e1ficos de dispersi\u00f3n. Imaginemos que queremos clasificar los diamantes seg\u00fan la calidad del corte (variable cut ). Para ello, usamos: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut )) ggplot2 interpreta autom\u00e1ticamente que, al no concretar la variable y , debe representar el n\u00famero total de diamantes por calidad de corte. Para ello, ggplot2 emplea unas transformaciones estadisticas capaces de crear nuevas variables modificando las ya existentes. En este caso, lo que hace es contar el n\u00famero de diamantes dentro de cada tipo de corte. Nota Si quieres saber m\u00e1s sobre estas transformaciones estad\u00edsticas, puedes encontrar m\u00e1s informaci\u00f3n aqu\u00ed . Al igual que el resto de gr\u00e1ficas, empleando aes() puedes modificar a apariencia del gr\u00e1fico de barras: color cambia el color del borde de las barras fill cambia el color del relleno Por ejemplo, podemos representar la claridad de los diamantes (variable ```clarity````) de la siguiente forma: 1 2 ggplot ( data = diamonds ) + geom_bar ( mapping = aes ( x = cut , fill = clarity )) Tambi\u00e9n podemos representar diagramas de cajas , empleando la funci\u00f3n geom_box . Como ejemplo, podemos representar el gasto en carretera seg\u00fan el tipo de coche de la siguiente manera: 1 2 ggplot ( data = mpg , mapping = aes ( x = class , y = hwy )) + geom_boxplot () Si necesitamos girar la gr\u00e1fica, simplemente a\u00f1adimos coord_flip() justo a continuaci\u00f3n de nuestra gr\u00e1fica: 1 2 3 ggplot ( data = mpg , mapping = aes ( x = class , y = hwy )) + geom_boxplot () + coord_flip () Razona: \u00bfA qu\u00e9 conclusi\u00f3n puedes llegar observando el ejemplo anterior?","title":"Gr\u00e1ficos estad\u00edsticos"},{"location":"visualizar/#graficas-multiples","text":"A veces, para facilitar la visualizaci\u00f3n de los datos, se intentan representar varias gr\u00e1ficas a la vez. Para ello, existen dos formas: Representar muchas variables dentro de una misma gr\u00e1fica ( por capas ). Dividir los datos en varias ventanas ( facets ).","title":"Gr\u00e1ficas m\u00faltiples"},{"location":"visualizar/#graficas-por-capas","text":"ggplot2 permite representar muchas variables en una misma gr\u00e1fica de forma sencilla. Supongamos que necesitamos representar una linea de tendencia del gasto en carretera con respecto a la cilindrada. Usando geom_smooth() dibujamos una linea de tendencia suavizada del conjuto de datos propuesto: 1 2 ggplot ( data = mpg ) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Nota Al igual que con el resto de funciones geom , geom_smooth() tambi\u00e9n posee sus aesthetics espec\u00edficos (tipo, grosor, color de linea...). Puedes usar ?geom_smooth para ver los que hay disponibles. Si quisieramos representar esta linea como una capa sobre un diagrama de dispersi\u00f3n, simplemente escribimos sus respectivas funciones geom una despu\u00e9s de la otra: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy , color = class )) + geom_smooth ( mapping = aes ( x = displ , y = hwy )) Podemos combinar tantas capas como queramos, siempre y cuando no existan incoherencias entre las variables representadas.","title":"Gr\u00e1ficas por capas"},{"location":"visualizar/#graficas-por-ventanas-facets","text":"Imaginemos que queremos representar el gasto en carretera con respecto a la cilindrada. Imaginemos tambi\u00e9n que queremos representar los tipos de veh\u00edculos. Podemos hacer como hicimos antes, es decir, representar por colores. Esto, sin embargo, a veces puede resultar en gr\u00e1ficas dif\u00edciles de observar, pues es complicado distinguir los diferentes valores. Para solucionar esto, podemos representar muchas gr\u00e1ficas a la vez, dividiendo las variables en numerosas ventanas. Para ello, usamos facet_wrap() . Se usa de la siguiente forma: 1 2 3 ggplot ( data = < DATOS > ) + < FUNCI\u00d3N_GEOM > ( mapping = aes ( < VARIABLES > )) + facet_wrap ( ~ < VARIABLE > , nrow = < N\u00daMERO DE FILAS > ) Representamos el ejemplo anterior: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_wrap ( ~ class , nrow = 2 ) Con facets podemos representar dos variables, empleando la funci\u00f3n facet_grid() . Por ejemplo, usemos como variables el tipo de tren de transmision y el n\u00famero de cilindros: 1 2 3 ggplot ( data = mpg ) + geom_point ( mapping = aes ( x = displ , y = hwy )) + facet_grid ( drv ~ cyl ) Los facets son muy \u00fatiles cuando queremos ver una visi\u00f3n global de todas las posibles representaciones que podemos hacer. Con ella, vemos multitud de gr\u00e1ficas a la vez y podemos seleccionar la que m\u00e1s nos interese.","title":"Gr\u00e1ficas por ventanas (facets)"},{"location":"visualizar/#ejercicios-de-repaso","text":"Para ver si has entendido todo, intenta realizar los ejercicios propuestos en este enlace . Nota Cosulta el apartado \" Realizaci\u00f3n de ejercicios \" para saber c\u00f3mo descargar, instalar y completar esta tarea.","title":"Ejercicios de repaso"},{"location":"visualizar/#referencias","text":"Referencias R for Data Science ; Hadley Wickham, Garrett Grolemund et al.","title":"Referencias"},{"location":"datos/","text":"Escribe fuente de datos","title":"Index"}]}